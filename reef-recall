#!/usr/bin/env bash
# reef-recall â€” move a file from the twin folder back to base and remove its symlink.
# Usage:
#   reef-recall <symlink> [--suffix=-reef]
# Behavior:
#   - Check that the argument is a symlink pointing to the twin folder.
#   - Move the target file from twin back to the original location.
#   - Remove the symlink.

set -euo pipefail

# Config

# Verbosity
verbose=0

# Parse flags (only -v/--verbose for now); leave positional SYMLINK arg intact
parsed_args=()
for arg in "$@"; do
  case "$arg" in
    -v|--verbose) verbose=1 ;;
    --) shift; break ;;
    -h|--help)
      echo "Usage: reef-recall [-v|--verbose] <symlink>"
      exit 0
      ;;
    -*)
      # Unknown flags will be handled later by existing logic or ignored
      ;;
    *)
      parsed_args+=("$arg")
      ;;
  esac
done
# Rebuild $@ with parsed_args (so the rest of the script works unchanged)
set -- "${parsed_args[@]}"

# vprintf: only print when verbose
vprintf() {
  if [ "$verbose" -eq 1 ]; then
    printf "%b" "$1" "${@:2}"
  fi
}
# ----- Configuration -----  
SUFFIX="-reef"   # default twin suffix

# ----- Colors & symbols (fallback to plain if not a TTY) -----
is_tty=0
if [ -t 1 ]; then is_tty=1; fi

if [ "$is_tty" -eq 1 ]; then
  RED="$(printf '\033[31m')"
  GREEN="$(printf '\033[32m')"
  YELLOW="$(printf '\033[33m')"
  DIM="$(printf '\033[2m')"
  BOLD="$(printf '\033[1m')"
  RESET="$(printf '\033[0m')"
  OK="âœ“"
  ERR="âœ—"
  DOT="â—"
  ARROW_RX="â†’"
  ARROW_LX="â†"
  CONNECT="â”"
  WARN="âš ï¸"
  FILE_ICON="ðŸ“„"
  FOLDER_ICON="ðŸ“"
  LINK_ICON="ðŸ”—"
else
  RED=""; GREEN=""; YELLOW=""; DIM=""; BOLD=""; RESET=""
  OK="[OK]"; ERR="[ERR]"; DOT="*"; ARROW_RX="->"; ARROW_LX="<-"; CONNECT="-"; WARN="[WARN]"; FILE_ICON="[F]"; FOLDER_ICON="[D]"; LINK_ICON="[L]"
fi

# Parse flags
for arg in "$@"; do
 case "$arg" in
   --suffix=*) SUFFIX="${arg#*=}";;
 esac
done

# Strip flags from $@ to get the first non-flag as the symlink arg
SYMLINK_ARG=""
for arg in "$@"; do
 case "$arg" in
   --suffix=*) ;;  # skip
   --*) ;;         # ignore unknown flags for now
   *) SYMLINK_ARG="$arg"; break;;
 esac
done

# Warn if no symlink provided
if [[ -z "${SYMLINK_ARG:-}" ]]; then
 vprintf "${YELLOW}${WARN}${RESET} A symlink was expected. Usage: reef-recall <symlink> [--suffix=-reef]\n"
 exit 0
fi

# Practical realpath that works for our use case
_realpath() {
 local path="$1"
 
 # Use system realpath with fallback to manual resolution
 if command -v realpath >/dev/null 2>&1; then
   realpath -m "$path" 2>/dev/null || echo "$path"
 else
   # Make absolute if relative
   if [[ "$path" != /* ]]; then
     path="$PWD/$path"
   fi
   
   # Basic cleanup
   path="${path//\/\///}"  # compress multiple slashes
   path="${path%/}"        # remove trailing slash
   [[ -n "$path" ]] || path="/"
   
   echo "$path"
 fi
}

# Determine BASE and TWIN from current dir with improved logic
CWD="$(_realpath "$PWD")"
BASE=""
TWIN=""

# Check if current directory ends with suffix AND a non-suffix version exists
if [[ "$CWD" == *"$SUFFIX" ]]; then
 potential_base="${CWD%$SUFFIX}"
 # Only treat as twin if the base actually exists
 if [[ -d "$potential_base" ]]; then
   TWIN="$CWD"
   BASE="$(_realpath "$potential_base")"
 fi
fi

# If we haven't identified BASE/TWIN yet, assume we're in base
if [[ -z "$BASE" ]]; then
 BASE="$CWD"
 TWIN="$(_realpath "${CWD}${SUFFIX}")"
fi

# Sanity check: BASE and TWIN shouldn't be the same
if [[ "$BASE" == "$TWIN" ]]; then
 printf "%s%s%s Base and twin directories are identical. Check your suffix configuration.\n" "$RED" "$ERR" "$RESET" >&2
 exit 1
fi

# Base must exist
if [[ ! -d "$BASE" ]]; then
 printf "%s%s%s Base folder not found: %s\n" "$RED" "$ERR" "$RESET" "$BASE" >&2
 exit 1
fi

# Check write permissions on base directory
if [[ ! -w "$BASE" ]]; then
 printf "%s%s%s No write permission on base directory: %s\n" "$RED" "$ERR" "$RESET" "$BASE" >&2
 exit 1
fi

# Twin folder missing â†’ error, can't recall from non-existent twin
if [[ ! -d "$TWIN" ]]; then
 printf "%s%s%s Twin folder not found: %s\n" "$RED" "$ERR" "$RESET" "$TWIN" >&2
 exit 1
fi

# Check write permissions on twin directory
if [[ ! -w "$TWIN" ]]; then
 printf "%s%s%s No write permission on twin directory: %s\n" "$RED" "$ERR" "$RESET" "$TWIN" >&2
 exit 1
fi

# Resolve symlink path
if [[ "$SYMLINK_ARG" = /* ]]; then
 SYMLINK="$SYMLINK_ARG"
else
 SYMLINK="$PWD/$SYMLINK_ARG"
fi
SYMLINK="$(_realpath "$SYMLINK")"

# Validations
if [[ ! -e "$SYMLINK" && ! -L "$SYMLINK" ]]; then
 printf "%s%s%s No such file or symlink: %s\n" "$RED" "$ERR" "$RESET" "$SYMLINK" >&2
 exit 1
fi

# Must be a symlink
if [[ ! -L "$SYMLINK" ]]; then
 printf "%s%s%s Not a symlink: %s\n" "$RED" "$ERR" "$RESET" "$SYMLINK" >&2
 exit 1
fi

# Get the symlink target
TARGET="$(readlink "$SYMLINK" 2>/dev/null || true)"
if [[ -z "$TARGET" ]]; then
 printf "%s%s%s Cannot read symlink target: %s\n" "$RED" "$ERR" "$RESET" "$SYMLINK" >&2
 exit 1
fi

# Resolve target to absolute path if it's relative
if [[ "$TARGET" == /* ]]; then
 # Already absolute
 ABS_TARGET="$TARGET"
else
 # Relative - resolve from the directory containing the symlink
 ABS_TARGET="$(_realpath "$(dirname -- "$SYMLINK")/$TARGET")"
fi

# Check if target is actually in the twin directory
case "$ABS_TARGET" in
 "$TWIN"/*)
   # Good, it's in the twin
   ;;
 "$TWIN")
   # Edge case: symlink points directly to twin directory
   printf "%s%s%s Cannot recall directory: %s points to twin folder itself\n" "$RED" "$ERR" "$RESET" "$SYMLINK" >&2
   exit 1
   ;;
 *)
   printf "%s%s%s Symlink does not point to twin folder: %s %s %s\n" "$RED" "$ERR" "$RESET" "$SYMLINK" "$ARROW_RX" "$ABS_TARGET" >&2
   exit 1
   ;;
esac

# Check if target file actually exists
if [[ ! -e "$ABS_TARGET" ]]; then
 printf "%s%s%s Target file does not exist in twin: %s\n" "$RED" "$ERR" "$RESET" "$ABS_TARGET" >&2
 exit 1
fi

# Check if target is readable/moveable
if [[ ! -r "$ABS_TARGET" ]]; then
 printf "%s%s%s Cannot read target file: %s\n" "$RED" "$ERR" "$RESET" "$ABS_TARGET" >&2
 exit 1
fi

# Check if we can remove from twin directory
TWIN_PARENT="$(dirname -- "$ABS_TARGET")"
if [[ ! -w "$TWIN_PARENT" ]]; then
 printf "%s%s%s Cannot move file from twin: %s (no write permission)\n" "$RED" "$ERR" "$RESET" "$TWIN_PARENT" >&2
 exit 1
fi

# Check if symlink parent directory allows removal
SYMLINK_DIR="$(dirname -- "$SYMLINK")"
if [[ ! -w "$SYMLINK_DIR" ]]; then
 printf "%s%s%s Cannot remove symlink from: %s (no write permission)\n" "$RED" "$ERR" "$RESET" "$SYMLINK_DIR" >&2
 exit 1
fi

vprintf "Recalling: ${DIM}%s${RESET}\n" "$ABS_TARGET"
vprintf "From twin: ${DIM}%s${RESET}\n" "$TWIN"
vprintf "To base:   ${DIM}%s${RESET}\n" "$SYMLINK"
vprintf "Remove:    ${DIM}%s${RESET}\n\n" "$SYMLINK"

# Remove the symlink first
if rm -- "$SYMLINK"; then
 vprintf "${GREEN}${OK}${RESET} Removed symlink: %s\n" "$SYMLINK"
else
 printf "%s%s%s Failed to remove symlink: %s\n" "$RED" "$ERR" "$RESET" "$SYMLINK" >&2
 exit 1
fi

# Move the file from twin back to original location
if mv -- "$ABS_TARGET" "$SYMLINK"; then
  # Verbose summary
  vprintf "${GREEN}${OK}${RESET} Recalled â† %s
" "$ABS_TARGET"
  vprintf "
${GREEN}${OK}${RESET} Done.
"
  # Concise line (default): icon + dashed unlink + red X + name
  name="$(basename "$SYMLINK")"
  if [ -d "$SYMLINK" ]; then icon="$FOLDER_ICON"; else icon="$FILE_ICON"; fi
  printf "%s %s   â—â•Œâ•Œâ•Œâ—‹   %sâœ—%s %s
" \
    "$icon" "$name" "$RED" "$RESET" "$name"
else
 printf "%s%s%s Move failed: %s %s %s\n" "$RED" "$ERR" "$RESET" "$SYMLINK" "$ARROW_LX" "$ABS_TARGET" >&2
 
 # Attempt rollback: recreate the symlink
 vprintf "${YELLOW}${WARN}${RESET} Attempting rollback...\n"
 if ln -s -- "$ABS_TARGET" "$SYMLINK" 2>/dev/null; then
   vprintf "${GREEN}${OK}${RESET} Rollback successful: symlink restored at %s\n" "$SYMLINK"
   exit 1
 else
   printf "%s%s%s Rollback failed! File is still at: %s\n" "$RED" "$ERR" "$RESET" "$ABS_TARGET" >&2
   printf "%s%s%s You may need to manually recreate symlink: %s %s %s\n" "$RED" "$ERR" "$RESET" "$SYMLINK" "$ARROW_RX" "$ABS_TARGET" >&2
   exit 1
 fi
fi

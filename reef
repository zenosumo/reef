#!/usr/bin/env bash
# reef â€” unified workspace twin management system
# 
# This script consolidates all reef-* commands into a single unified interface:
# - reef kick <path>      (was reef-kick)
# - reef status           (was reef-status)  
# - reef plug             (was reef-plug)
# - reef recall <symlink> (was reef-recall)
# - reef unplug           (was reef-unplug)
#
# Usage: reef [GLOBAL_OPTIONS] <SUBCOMMAND> [SUBCOMMAND_ARGS...]
#        reef --help (or no args) shows main help
#        reef <subcommand> --help shows subcommand help

set -euo pipefail

# =============================================================================
# 1. VERSION AND CONFIGURATION
# =============================================================================

VERSION="2.0.0"
SUFFIX="-reef"   # default twin suffix

# =============================================================================
# 2. TTY DETECTION AND COLOR VARIABLES
# =============================================================================

# TTY detection - determines if we're in an interactive terminal
is_tty=0
if [ -t 1 ]; then is_tty=1; fi

# Color and symbol setup with fallback for non-TTY environments
setup_tty_detection() {
  if [ "$is_tty" -eq 1 ]; then
    # Full color and Unicode symbols for interactive terminals
    RED="$(printf '\033[31m')"
    LIGHTRED="$(printf '\033[91m')"
    GREEN="$(printf '\033[32m')"
    YELLOW="$(printf '\033[33m')"
    BLUE="$(printf '\033[34m')"
    CYAN="$(printf '\033[36m')"
    MAGENTA="$(printf '\033[35m')"
    DIM="$(printf '\033[2m')"
    BOLD="$(printf '\033[1m')"
    RESET="$(printf '\033[0m')"
    
    # Status symbols
    OK="âœ“"
    ERR="âœ—"
    DOT="â—"
    WARN="âš ï¸"
    
    # Arrow symbols
    ARROW_RX="â†’"
    ARROW_LX="â†"
    TRIANGLE_RX="â–¶"
    TRIANGLE_LX="â—€"
    CONNECT="â”"
    CONNECT_DASH="â•Œ"
    
    # File type icons
    FILE_ICON="ðŸ“„"
    FOLDER_ICON="ðŸ“"
    LINK_ICON="ðŸ”—"
    SKULL_ICON="ðŸ’€"
  else
    # Plain text fallback for non-interactive environments (CI/CD, pipes, etc.)
    RED=""; LIGHTRED=""; GREEN=""; YELLOW=""; BLUE=""; CYAN=""; MAGENTA=""
    DIM=""; BOLD=""; RESET=""
    
    # Plain text status symbols
    OK="[OK]"
    ERR="[ERR]"
    DOT="*"
    WARN="[WARN]"
    
    # Plain text arrows
    ARROW_RX="->"
    ARROW_LX="<-"
    TRIANGLE_RX=">"
    TRIANGLE_LX="<"
    CONNECT="-"
    CONNECT_DASH="-"
    
    # Plain text file type indicators
    FILE_ICON="[F]"
    FOLDER_ICON="[D]"
    LINK_ICON="[L]"
    SKULL_ICON="[BROKEN]"
  fi
}

# Initialize TTY detection and colors
setup_tty_detection

# =============================================================================
# 3. SHARED UTILITY FUNCTIONS
# =============================================================================

# Portable realpath function that works on both macOS/BSD and Linux
# Handles non-existent paths gracefully and resolves to absolute paths
_realpath() {
  local path="$1"
  
  # Use system realpath with fallback to manual resolution
  if command -v realpath >/dev/null 2>&1; then
    realpath -m "$path" 2>/dev/null || echo "$path"
  else
    # Make absolute if relative
    if [[ "$path" != /* ]]; then
      path="$PWD/$path"
    fi
    
    # Basic cleanup
    path="${path//\/\///}"  # compress multiple slashes
    path="${path%/}"        # remove trailing slash
    [[ -n "$path" ]] || path="/"
    
    echo "$path"
  fi
}

# Common error handling functions with consistent formatting
print_error() {
  local message="$1"
  printf "%s%s Error:%s %s\n" "$RED" "$ERR" "$RESET" "$message" >&2
}

print_success() {
  local message="$1"
  printf "%s%s%s %s\n" "$GREEN" "$OK" "$RESET" "$message"
}

print_warning() {
  local message="$1"
  printf "%s%s Warning:%s %s\n" "$YELLOW" "$WARN" "$RESET" "$message"
}

# Helper function for verbose output (only prints when verbose=1)
vprintf() {
  if [ "${verbose:-0}" -eq 1 ]; then 
    printf "%b" "$@"
  fi
}

# Ask yes/no question with default to yes (used by reef-kick)
ask_yes_default_yes() {
  local prompt="$1"
  local reply
  if [ -t 0 ]; then
    read -r -p "$prompt [Y/n] " reply
  else
    reply="y"
  fi
  case "$reply" in
    [nN]*) return 1 ;;
    *) return 0 ;;
  esac
}

# Function to truncate filename if longer than 15 chars (used by reef-status)
_truncate_name() {
  local name="$1"
  if [[ ${#name} -gt 15 ]]; then
    printf "%.14sâ€¦" "$name"
  else
    printf "%s" "$name"
  fi
}

# =============================================================================
# 4. BASE/TWIN DETECTION LOGIC
# =============================================================================

# Global variables for base and twin directories
BASE=""
TWIN=""

# Determine BASE and TWIN directories from current working directory
# This logic is shared across all reef commands
detect_base_twin() {
  local cwd suffix
  cwd="$(_realpath "$PWD")"
  suffix="${SUFFIX}"
  
  BASE=""
  TWIN=""
  
  # Check if current directory ends with suffix AND a non-suffix version exists
  if [[ "$cwd" == *"$suffix" ]]; then
    local potential_base="${cwd%$suffix}"
    # Only treat as twin if the base actually exists
    if [[ -d "$potential_base" ]]; then
      TWIN="$cwd"
      BASE="$(_realpath "$potential_base")"
    fi
  fi
  
  # If we haven't identified BASE/TWIN yet, assume we're in base
  if [[ -z "$BASE" ]]; then
    BASE="$cwd"
    
    # First: Check for twin at same level
    local same_level_twin="${cwd}${suffix}"
    if [[ -d "$same_level_twin" ]]; then
      TWIN="$same_level_twin"
    else
      # Second: Check for twin in ~/.reef/
      local project_name="$(basename "$cwd")"
      local reef_home="${HOME}/.reef"
      local alt_twin="${reef_home}/${project_name}${suffix}"
      
      if [[ -d "$alt_twin" ]]; then
        TWIN="$(_realpath "$alt_twin")"
      else
        # Default to same-level path (for creation)
        TWIN="$same_level_twin"
      fi
    fi
  fi
  
  # Sanity check: BASE and TWIN shouldn't be the same
  if [[ "$BASE" == "$TWIN" ]]; then
    print_error "Base and twin directories are identical. Check your suffix configuration."
    exit 1
  fi
}

# =============================================================================
# 5. GLOBAL ARGUMENT PARSING
# =============================================================================

# Global variables for command-line options
verbose=0
show_help=0
show_version=0
args=()

# Parse global arguments (before subcommand)
parse_global_args() {
  local parsing_global=1
  
  while [[ $# -gt 0 && $parsing_global -eq 1 ]]; do
    case "$1" in
      -h|--help)
        show_help=1
        shift
        ;;
      -v|--version)  
        show_version=1
        shift
        ;;
      --suffix=*)
        SUFFIX="${1#*=}"
        shift
        ;;
      --suffix)
        if [[ $# -lt 2 ]]; then
          print_error "Option --suffix requires a value"
          exit 2
        fi
        SUFFIX="$2"
        shift 2
        ;;
      -*)
        # Unknown global option - might be subcommand option, stop global parsing
        parsing_global=0
        ;;
      *)
        # Non-option argument - this starts subcommand parsing
        parsing_global=0
        ;;
    esac
  done
  
  # Store remaining arguments for subcommand processing
  args=("$@")
}

# =============================================================================
# 6. MAIN HELP SYSTEM AND VERSION DISPLAY
# =============================================================================

show_version() {
  printf "reef version %s\n" "$VERSION"
  printf "Workspace twin management system\n"
}

show_main_help() {
  cat <<EOF
reef - Workspace twin management system

Usage: reef [OPTIONS] <SUBCOMMAND> [ARGS...]

SUBCOMMANDS:
  kick <path>     Move file/dir to twin and replace with symlink
  status          Show relationships between base and twin files
  plug            Create symlinks in base for all twin contents  
  recall <link>   Move file back from twin to base
  unplug          Remove all symlinks pointing to twin

GLOBAL OPTIONS:
  -h, --help           Show this help
  -v, --version        Show version information
  --suffix=SUFFIX      Use custom twin suffix (default: -reef)

EXAMPLES:
  reef kick src/index.js       # Move file to twin
  reef status --verbose        # Show detailed status
  reef plug                    # Link all twin files
  reef recall src/index.js     # Move file back
  reef unplug                  # Remove all twin links

For help with a specific subcommand: reef <subcommand> --help

Key concepts:
- BASE: Main project directory (e.g., myproject/)
- TWIN: Parallel directory with suffix (e.g., myproject-reef/)
- Files can be moved between BASE and TWIN with automatic symlinking
EOF
}

# =============================================================================
# 7. SUBCOMMAND IMPLEMENTATIONS
# =============================================================================
# (These will be added in subsequent iterations - framework is ready)

# Placeholder subcommand functions - to be implemented
# =============================================================================
# SUBCOMMAND: KICK
# =============================================================================

kick_show_help() {
  cat <<EOF
reef kick â€” move a file/dir into the twin and link it back

Usage:
  reef kick [-v|--verbose] <path-inside-project>

Options:
  -v, --verbose    Show detailed multi-line progress output
  -h, --help       Show this help

Examples:
  reef kick src/index.ts
  reef kick --verbose config

Notes:
  - Run inside your project BASE or its twin directory.
  - If the twin directory doesn't exist, you'll be asked to create it.
EOF
}

cmd_kick() {
  # Local variables for kick subcommand
  local verbose=0
  local show_help=0
  local args=()
  
  # Parse kick-specific arguments
  for arg in "$@"; do
    case "$arg" in
      -v|--verbose)
        verbose=1
        ;;
      -h|--help)
        show_help=1
        ;;
      -*)
        print_error "kick: unknown option: $arg"
        printf "Run 'reef kick --help' for usage information.\n" >&2
        exit 2
        ;;
      *)
        args+=("$arg")
        ;;
    esac
  done
  
  # Show help if requested
  if [[ $show_help -eq 1 ]]; then
    kick_show_help
    exit 0
  fi
  
  # Kick requires exactly one path argument
  if [[ ${#args[@]} -eq 0 ]]; then
    print_error "kick: missing required argument <path-inside-project>"
    printf "Usage: reef kick [-v|--verbose] <path-inside-project>\n" >&2
    exit 2
  elif [[ ${#args[@]} -gt 1 ]]; then
    print_error "kick: too many arguments. Expected 1 path, got ${#args[@]}"
    printf "Usage: reef kick [-v|--verbose] <path-inside-project>\n" >&2
    exit 2
  fi
  
  local rel_path="${args[0]}"
  local src="$BASE/$rel_path"
  local dest="$TWIN/$rel_path"
  
  # Validate source exists
  if [[ ! -e "$src" ]]; then
    print_error "kick: not found: $src"
    exit 1
  fi
  
  # Must not already be a symlink pointing to twin
  if [[ -L "$src" ]]; then
    local link_target
    link_target="$(readlink "$src")"
    # Normalize relative link target to absolute for comparison
    if [[ "$link_target" != /* ]]; then
      link_target="$(cd "$(dirname "$src")" && _realpath "$link_target")"
    fi
    # Compute absolute intended destination
    local abs_dest
    abs_dest="$(cd "$TWIN" 2>/dev/null && _realpath "$dest" 2>/dev/null || echo "$dest")"
    if [[ "$link_target" = "$abs_dest" ]]; then
      print_warning "Already linked: $src â†’ $dest"
      exit 1
    fi
  fi
  
  # Ensure twin exists (or create)
  if [[ ! -d "$TWIN" ]]; then
    # Always create at same level when prompting
    local create_path="${BASE}${SUFFIX}"
    if ask_yes_default_yes "Twin folder does not exist. Create it at: $create_path?"; then
      mkdir -p "$create_path"
      # Update TWIN to the newly created path
      TWIN="$create_path"
      if [[ $verbose -eq 1 ]]; then
        printf "Created twin: %s\n" "$TWIN"
      fi
    else
      print_error "kick: twin folder missing: $TWIN"
      exit 1
    fi
  fi
  
  # Refuse if destination exists
  if [[ -e "$dest" ]]; then
    print_error "kick: target already exists in twin: $dest"
    exit 1
  fi
  
  # Verbose progress output
  if [[ $verbose -eq 1 ]]; then
    printf "Moving:    %s%s%s\n" "$DIM" "$src" "$RESET"
    printf "To twin:   %s%s%s\n" "$DIM" "$dest" "$RESET"
    printf "Link back: %s%s%s\n\n" "$DIM" "$src" "$RESET"
  fi
  
  # Ensure parent dir in twin
  mkdir -p "$(dirname "$dest")"
  
  # Move then link; on failure, attempt rollback
  local mv_status ln_status
  
  # Disable errexit for controlled error handling
  set +e
  mv "$src" "$dest"
  mv_status=$?
  if [[ $mv_status -ne 0 ]]; then
    print_error "kick: failed to move $src to $dest"
    set -e
    exit 1
  fi
  
  ln -s "$(_realpath "$dest")" "$src"
  ln_status=$?
  if [[ $ln_status -ne 0 ]]; then
    # rollback move
    mv "$dest" "$src" 2>/dev/null
    print_error "kick: failed to create symlink. Rolled back."
    set -e
    exit 1
  fi
  set -e
  
  # Output results
  if [[ $verbose -eq 1 ]]; then
    print_success "Moved $src â†’ $dest"
    print_success "Linked $src â†’ $dest"
    printf "\n%s%s%s Done.\n" "$GREEN" "$OK" "$RESET"
  else
    # Concise, reef-status-like with fixed-width connection
    local base_name_only twin_name_only icon name_len connection_line
    base_name_only="$(basename "$BASE")"
    twin_name_only="$(basename "$TWIN")"
    
    # Determine if it's a file or folder
    if [[ -d "$dest" ]]; then
      icon="$FOLDER_ICON"
    else
      icon="$FILE_ICON"
    fi
    
    # Calculate connection line length based on filename length (like reef-status)
    name_len=${#rel_path}
    [[ $name_len -lt 10 ]] && name_len=10
    connection_line=""
    for ((i=0; i<name_len; i++)); do
      connection_line+="$CONNECT"
    done
    
    printf "%s %-*s %s%s%s %s %s/%s\n" "$LINK_ICON" $name_len "$rel_path" "$DOT" "$connection_line" "$TRIANGLE_RX" "$icon" "$twin_name_only" "$rel_path"
  fi
}

# =============================================================================
# SUBCOMMAND: STATUS
# =============================================================================

status_show_help() {
  cat <<EOF
reef status â€” display the relationship between base and twin folder files

Usage:
  reef status [-v|--verbose] [--help]

Options:
  -v, --verbose    Show detailed visual diagram with alignment
  -h, --help       Show this help

Examples:
  reef status
  reef status --verbose

Output:
  Default: Concise list of files and their status
  Verbose: Visual diagram showing connections between base and twin
EOF
}

cmd_status() {
  # Local variables for status subcommand
  local verbose=0
  local show_help=0
  local args=()
  
  # Parse status-specific arguments
  for arg in "$@"; do
    case "$arg" in
      -v|--verbose)
        verbose=1
        ;;
      -h|--help)
        show_help=1
        ;;
      -*)
        print_error "status: unknown option: $arg"
        printf "Run 'reef status --help' for usage information.\n" >&2
        exit 2
        ;;
      *)
        args+=("$arg")
        ;;
    esac
  done
  
  # Show help if requested
  if [[ $show_help -eq 1 ]]; then
    status_show_help
    exit 0
  fi
  
  # Status takes no positional arguments
  if [[ ${#args[@]} -ne 0 ]]; then
    print_error "status: unexpected arguments. reef status takes no positional arguments."
    printf "Usage: reef status [-v|--verbose]\n" >&2
    exit 2
  fi
  
  # BASE/TWIN should already be set by main() calling detect_base_twin()
  # Validate BASE exists
  if [[ ! -d "$BASE" ]]; then
    print_error "Base folder not found: $BASE"
    exit 1
  fi
  
  # Twin folder missing â†’ show empty state
  if [[ ! -d "$TWIN" ]]; then
    print_warning "Twin folder not found: $TWIN"
    printf "%sNo twin workspace initialized.%s\n" "$DIM" "$RESET"
    exit 0
  fi
  
  # Collect file information
  local broken_dirs=()
  local broken_files=()
  local linked_dirs=()
  local linked_files=()
  local unlinked_dirs=()
  local unlinked_files=()
  
  # Store original shell options
  local original_shopt
  original_shopt=$(shopt -p dotglob nullglob 2>/dev/null || true)
  shopt -s dotglob nullglob
  
  # Scan BASE for symlinks
  local item name target abs_target
  for item in "$BASE"/*; do
    [[ -e "$item" || -L "$item" ]] || continue
    
    name="$(basename -- "$item")"
    [[ "$name" == "." || "$name" == ".." ]] && continue
    
    if [[ -L "$item" ]]; then
      # It's a symlink, check if it points to twin
      target="$(readlink "$item" 2>/dev/null || true)"
      if [[ -n "$target" ]]; then
        # Resolve to absolute path
        if [[ "$target" == /* ]]; then
          abs_target="$target"
        else
          abs_target="$(_realpath "$(dirname -- "$item")/$target")"
        fi
        
        # Check if target is in twin directory
        case "$abs_target" in
          "$TWIN"|"$TWIN"/*)
            if [[ -e "$abs_target" ]]; then
              # Healthy link
              if [[ -d "$abs_target" ]]; then
                linked_dirs+=("$name")
              else
                linked_files+=("$name")
              fi
            else
              # Broken link
              if [[ -d "$item" ]] 2>/dev/null; then
                broken_dirs+=("$name")
              else
                broken_files+=("$name")
              fi
            fi
            ;;
        esac
      fi
    fi
  done
  
  # Scan TWIN for files not linked back
  for item in "$TWIN"/*; do
    [[ -e "$item" ]] || continue
    
    name="$(basename -- "$item")"
    [[ "$name" == "." || "$name" == ".." ]] && continue
    
    # Check if there's a corresponding symlink in BASE
    local base_item="$BASE/$name"
    if [[ -L "$base_item" ]]; then
      # There's a symlink, check if it points to this item
      target="$(readlink "$base_item" 2>/dev/null || true)"
      if [[ -n "$target" ]]; then
        if [[ "$target" == /* ]]; then
          abs_target="$target"
        else
          abs_target="$(_realpath "$(dirname -- "$base_item")/$target")"
        fi
        
        # If it points to this item, it's already in linked arrays
        if [[ "$abs_target" == "$item" ]]; then
          continue
        fi
      fi
    fi
    
    # Not linked back to base
    if [[ -d "$item" ]]; then
      unlinked_dirs+=("$name")
    else
      unlinked_files+=("$name")
    fi
  done
  
  # Restore original shell options
  if [[ -n "$original_shopt" ]]; then
    eval "$original_shopt"
  else
    shopt -u dotglob nullglob 2>/dev/null || true
  fi
  
  # Calculate maximum filename length for alignment
  local max_len=0
  local all_names=()
  
  # Safe array concatenation
  [[ ${#broken_dirs[@]} -gt 0 ]] && all_names+=("${broken_dirs[@]}")
  [[ ${#broken_files[@]} -gt 0 ]] && all_names+=("${broken_files[@]}")
  [[ ${#linked_dirs[@]} -gt 0 ]] && all_names+=("${linked_dirs[@]}")
  [[ ${#linked_files[@]} -gt 0 ]] && all_names+=("${linked_files[@]}")
  [[ ${#unlinked_dirs[@]} -gt 0 ]] && all_names+=("${unlinked_dirs[@]}")
  [[ ${#unlinked_files[@]} -gt 0 ]] && all_names+=("${unlinked_files[@]}")
  
  if [[ ${#all_names[@]} -gt 0 ]]; then
    local truncated len
    for name in "${all_names[@]}"; do
      truncated="$(_truncate_name "$name")"
      len=${#truncated}
      [[ $len -gt $max_len ]] && max_len=$len
    done
  fi
  
  # Ensure minimum width for alignment
  [[ $max_len -lt 10 ]] && max_len=10
  
  # Calculate connection line length - fixed width based on longest filename
  local connection_line=""
  for ((i=0; i<max_len; i++)); do
    connection_line+="$CONNECT"
  done
  
  # Check if there are any items to display
  local total_items=$((${#broken_dirs[@]} + ${#broken_files[@]} + ${#linked_dirs[@]} + ${#linked_files[@]} + ${#unlinked_dirs[@]} + ${#unlinked_files[@]}))
  
  if [[ $total_items -eq 0 ]]; then
    printf "%sNo files found in workspace.%s\n" "$DIM" "$RESET"
    exit 0
  fi
  
  # Choose output format and execute
  if [[ $verbose -eq 1 ]]; then
    # Verbose: show detailed visual diagram
    printf "Checking links between: %s%s%s\n" "$DIM" "$BASE" "$RESET"
    printf "And twin directory:     %s%s%s\n\n" "$DIM" "$TWIN" "$RESET"

    # Print broken links first (folders, then files)
    if [[ ${#broken_dirs[@]} -gt 0 ]]; then
      for name in "${broken_dirs[@]}"; do
        printf "%s%s%s %s %s(broken link to twin)%s\n" "$RED" "$ERR" "$RESET" "$name" "$DIM" "$RESET"
      done
    fi

    if [[ ${#broken_files[@]} -gt 0 ]]; then
      for name in "${broken_files[@]}"; do
        printf "%s%s%s %s %s(broken link to twin)%s\n" "$RED" "$ERR" "$RESET" "$name" "$DIM" "$RESET"
      done
    fi

    # Print linked items (folders first, then files)
    if [[ ${#linked_dirs[@]} -gt 0 ]]; then
      for name in "${linked_dirs[@]}"; do
        printf "%s%s%s %s %s(linked to twin)%s\n" "$GREEN" "$OK" "$RESET" "$name" "$DIM" "$RESET"
      done
    fi

    if [[ ${#linked_files[@]} -gt 0 ]]; then
      for name in "${linked_files[@]}"; do
        printf "%s%s%s %s %s(linked to twin)%s\n" "$GREEN" "$OK" "$RESET" "$name" "$DIM" "$RESET"
      done
    fi

    # Print unlinked items (folders first, then files)
    if [[ ${#unlinked_dirs[@]} -gt 0 ]]; then
      for name in "${unlinked_dirs[@]}"; do
        printf "%s%s%s %s %s(unlinked in twin, ready to plug)%s\n" "$YELLOW" "$WARN" "$RESET" "$name" "$DIM" "$RESET"
      done
    fi

    if [[ ${#unlinked_files[@]} -gt 0 ]]; then
      for name in "${unlinked_files[@]}"; do
        printf "%s%s%s %s %s(unlinked in twin, ready to plug)%s\n" "$YELLOW" "$WARN" "$RESET" "$name" "$DIM" "$RESET"
      done
    fi

    # Summary
    local linked_count=$((${#linked_dirs[@]} + ${#linked_files[@]}))
    local unlinked_count=$((${#unlinked_dirs[@]} + ${#unlinked_files[@]}))
    local broken_count=$((${#broken_dirs[@]} + ${#broken_files[@]}))
    
    printf "\nStatus: %d linked, %d unlinked, %d broken\n" "$linked_count" "$unlinked_count" "$broken_count"
  else
    # Concise: simple list format
    # Show broken links with skull icon in light red
    if [[ ${#broken_dirs[@]} -gt 0 ]]; then
      for name in "${broken_dirs[@]}"; do
        printf "%s%s %s%s\n" "$LIGHTRED" "$SKULL_ICON" "$name" "$RESET"
      done
    fi
    if [[ ${#broken_files[@]} -gt 0 ]]; then
      for name in "${broken_files[@]}"; do
        printf "%s%s %s%s\n" "$LIGHTRED" "$SKULL_ICON" "$name" "$RESET"
      done
    fi
    
    # Show linked items with concise format in cyan
    if [[ ${#linked_dirs[@]} -gt 0 ]]; then
      for name in "${linked_dirs[@]}"; do
        printf "%s%s %-*s %s%s%s %s %s%s\n" "$CYAN" "$LINK_ICON" $max_len "$name" "$DOT" "$connection_line" "$DOT" "$FOLDER_ICON" "$name" "$RESET"
      done
    fi
    if [[ ${#linked_files[@]} -gt 0 ]]; then
      for name in "${linked_files[@]}"; do
        printf "%s%s %-*s %s%s%s %s %s%s\n" "$CYAN" "$LINK_ICON" $max_len "$name" "$DOT" "$connection_line" "$DOT" "$FILE_ICON" "$name" "$RESET"
      done
    fi
    
    # Show unlinked items (ready to plug) in yellow with dot format
    if [[ ${#unlinked_dirs[@]} -gt 0 ]]; then
      for name in "${unlinked_dirs[@]}"; do
        printf "%s                   %s %s %s%s\n" "$YELLOW" "$DOT" "$FOLDER_ICON" "$name" "$RESET"
      done
    fi
    if [[ ${#unlinked_files[@]} -gt 0 ]]; then
      for name in "${unlinked_files[@]}"; do
        printf "%s                   %s %s %s%s\n" "$YELLOW" "$DOT" "$FILE_ICON" "$name" "$RESET"
      done
    fi
  fi
}

# =============================================================================
# SUBCOMMAND: PLUG
# =============================================================================

plug_show_help() {
  cat <<EOF
reef plug â€” link files/dirs from the twin folder into the base folder

Usage:
  reef plug [-v|--verbose]

Options:
  -v, --verbose    Show detailed output for each operation
  -h, --help       Show this help

Examples:
  reef plug
  reef plug --verbose

Notes:
  - Creates symlinks in base directory for all files/directories in twin
  - Skips items that already exist in base (unless already correctly linked)
  - Idempotent: safe to run multiple times
  - Requires write permission on base directory
EOF
}

cmd_plug() {
  # Local variables for plug subcommand
  local verbose=0
  local show_help=0
  local args=()
  
  # Parse plug-specific arguments
  for arg in "$@"; do
    case "$arg" in
      -v|--verbose)
        verbose=1
        ;;
      -h|--help)
        show_help=1
        ;;
      -*)
        print_error "plug: unknown option: $arg"
        printf "Run 'reef plug --help' for usage information.\n" >&2
        exit 2
        ;;
      *)
        args+=("$arg")
        ;;
    esac
  done
  
  # Show help if requested
  if [[ $show_help -eq 1 ]]; then
    plug_show_help
    exit 0
  fi
  
  # reef-plug takes no positional arguments
  if [[ ${#args[@]} -ne 0 ]]; then
    print_error "plug: unexpected arguments. reef plug takes no positional arguments."
    printf "Usage: reef plug [-v|--verbose]\n" >&2
    exit 2
  fi
  
  # BASE/TWIN should already be set by main() calling detect_base_twin()
  # Validate BASE exists
  if [[ ! -d "$BASE" ]]; then
    print_error "plug: Base folder not found: $BASE"
    exit 1
  fi
  
  # Twin folder missing â†’ warning and exit gracefully
  if [[ ! -d "$TWIN" ]]; then
    print_warning "plug: Twin '$SUFFIX' folder not found: $TWIN"
    exit 0
  fi
  
  # Check write permissions on base directory
  if [[ ! -w "$BASE" ]]; then
    print_error "plug: No write permission on base directory: $BASE"
    exit 1
  fi
  
  if [[ $verbose -eq 1 ]]; then
    printf "Linking from: %s%s%s\n" "$DIM" "$TWIN" "$RESET"
    printf "Into base:    %s%s%s\n\n" "$DIM" "$BASE" "$RESET"
  fi
  
  # Store original shell options
  local original_shopt
  original_shopt=$(shopt -p dotglob nullglob 2>/dev/null || true)
  
  # Collect all filenames first to calculate max length
  shopt -s dotglob nullglob
  local all_names=()
  local src name
  
  for src in "$TWIN"/*; do
    name="$(basename -- "$src")"
    [[ "$name" == "." || "$name" == ".." ]] && continue
    all_names+=("$name")
  done
  
  # Calculate maximum filename length for alignment
  local max_len=0 len
  if [[ ${#all_names[@]} -gt 0 ]]; then
    for name in "${all_names[@]}"; do
      len=${#name}
      [[ $len -gt $max_len ]] && max_len=$len
    done
  fi
  
  # Ensure minimum width for alignment
  [[ $max_len -lt 10 ]] && max_len=10
  
  # Calculate connection line length - fixed width based on longest filename
  local connection_line=""
  local i
  for ((i=0; i<max_len; i++)); do
    connection_line+="$CONNECT"
  done
  
  # Link each top-level item from TWIN into BASE
  local created=0 had_any=0 dst icon
  
  for src in "$TWIN"/*; do
    had_any=1
    name="$(basename -- "$src")"
    dst="$BASE/$name"

    [[ "$name" == "." || "$name" == ".." ]] && continue

    # Determine if it's a file or folder
    if [[ -d "$src" ]]; then
      icon="$FOLDER_ICON"
    else
      icon="$FILE_ICON"
    fi

    if [[ -L "$dst" ]]; then
      # Check if it's pointing to our twin (idempotent behavior)
      if [[ "$(readlink "$dst")" == "$src" ]]; then
        if [[ $verbose -eq 1 ]]; then
          printf "%s%s%s %s %s(already linked correctly)%s\n" "$DIM" "$OK" "$RESET" "$name" "$DIM" "$RESET"
        fi
        # Concise: show already linked with fixed width
        if [[ $verbose -eq 0 ]]; then
          printf "%s %-*s %s%s%s %s %s\n" "$LINK_ICON" $max_len "$name" "$DOT" "$connection_line" "$DOT" "$icon" "$name"
        fi
      else
        printf "%s%s%s %s %s(linked to different target)%s\n" "$RED" "$ERR" "$RESET" "$name" "$DIM" "$RESET"
      fi
      continue
    elif [[ -e "$dst" ]]; then
      printf "%s%s%s %s %s(exists, not a symlink)%s\n" "$RED" "$ERR" "$RESET" "$name" "$DIM" "$RESET"
      continue
    fi

    if ln -s "$src" "$dst" 2>/dev/null; then
      # Verbose: detailed output
      if [[ $verbose -eq 1 ]]; then
        printf "%s%s%s %s\n" "$GREEN" "$OK" "$RESET" "$name"
      fi
      # Concise: visual link representation with fixed width
      if [[ $verbose -eq 0 ]]; then
        printf "%s%s%s %-*s %s%s%s %s %s\n" "$GREEN" "$LINK_ICON" "$RESET" $max_len "$name" "$TRIANGLE_LX" "$connection_line" "$DOT" "$icon" "$name"
      fi
      created=$((created+1))
    else
      printf "%s%s%s %s %s(link failed)%s\n" "$RED" "$ERR" "$RESET" "$name" "$DIM" "$RESET"
    fi
  done
  
  # Restore original shell options
  if [[ -n "$original_shopt" ]]; then
    eval "$original_shopt"
  else
    shopt -u dotglob nullglob 2>/dev/null || true
  fi
  
  if [[ $had_any -eq 0 ]]; then
    printf "%sNothing to link: %s is empty.%s\n" "$DIM" "$TWIN" "$RESET"
  fi
  
  # Summary only in verbose mode
  if [[ $verbose -eq 1 ]]; then
    printf "\nCreated %d link(s).\n" "$created"
  fi
}

# =============================================================================
# SUBCOMMAND: RECALL
# =============================================================================

recall_show_help() {
  cat <<EOF
reef recall â€” move a file from the twin folder back to base and remove its symlink

Usage:
  reef recall [-v|--verbose] <symlink>

Options:
  -v, --verbose    Show detailed output for each operation
  -h, --help       Show this help

Examples:
  reef recall myfile
  reef recall --verbose config/settings.json
  reef recall src/components/Button.tsx

Notes:
  - Argument must be a symlink pointing to a file in the twin folder
  - Moves the target file from twin back to the original location
  - Removes the symlink after successful move
  - Includes rollback on failure
EOF
}

cmd_recall() {
  # Local variables for recall subcommand
  local verbose=0
  local show_help=0
  local args=()
  
  # Parse recall-specific arguments
  for arg in "$@"; do
    case "$arg" in
      -v|--verbose)
        verbose=1
        ;;
      -h|--help)
        show_help=1
        ;;
      -*)
        print_error "recall: unknown option: $arg"
        printf "Run 'reef recall --help' for usage information.\n" >&2
        exit 2
        ;;
      *)
        args+=("$arg")
        ;;
    esac
  done
  
  # Show help if requested
  if [[ $show_help -eq 1 ]]; then
    recall_show_help
    exit 0
  fi
  
  # Check for required symlink argument
  if [[ ${#args[@]} -eq 0 ]]; then
    print_error "recall: missing required argument <symlink>"
    printf "Usage: reef recall [-v|--verbose] <symlink>\n" >&2
    exit 2
  elif [[ ${#args[@]} -gt 1 ]]; then
    print_error "recall: too many arguments. Expected 1 symlink, got ${#args[@]}"
    printf "Usage: reef recall [-v|--verbose] <symlink>\n" >&2
    exit 2
  fi
  
  local symlink_arg="${args[0]}"
  
  # BASE/TWIN should already be set by main() calling detect_base_twin()
  # Validate BASE exists
  if [[ ! -d "$BASE" ]]; then
    print_error "recall: Base folder not found: $BASE"
    exit 1
  fi
  
  # Check write permissions on base directory
  if [[ ! -w "$BASE" ]]; then
    print_error "recall: No write permission on base directory: $BASE"
    exit 1
  fi
  
  # Twin folder missing â†’ error, can't recall from non-existent twin
  if [[ ! -d "$TWIN" ]]; then
    print_error "recall: Twin folder not found: $TWIN"
    exit 1
  fi
  
  # Check write permissions on twin directory
  if [[ ! -w "$TWIN" ]]; then
    print_error "recall: No write permission on twin directory: $TWIN"
    exit 1
  fi
  
  # Resolve symlink path
  local symlink
  if [[ "$symlink_arg" = /* ]]; then
    symlink="$symlink_arg"
  else
    symlink="$PWD/$symlink_arg"
  fi
  symlink="$(_realpath "$symlink")"
  
  # Validations
  if [[ ! -e "$symlink" && ! -L "$symlink" ]]; then
    print_error "recall: No such file or symlink: $symlink"
    exit 1
  fi
  
  # Must be a symlink
  if [[ ! -L "$symlink" ]]; then
    print_error "recall: Not a symlink: $symlink"
    exit 1
  fi
  
  # Get the symlink target
  local target
  target="$(readlink "$symlink" 2>/dev/null || true)"
  if [[ -z "$target" ]]; then
    print_error "recall: Cannot read symlink target: $symlink"
    exit 1
  fi
  
  # Resolve target to absolute path if it's relative
  local abs_target
  if [[ "$target" == /* ]]; then
    # Already absolute
    abs_target="$target"
  else
    # Relative - resolve from the directory containing the symlink
    abs_target="$(_realpath "$(dirname -- "$symlink")/$target")"
  fi
  
  # Check if target is actually in the twin directory
  case "$abs_target" in
    "$TWIN"/*)
      # Good, it's in the twin
      ;;
    "$TWIN")
      # Edge case: symlink points directly to twin directory
      print_error "recall: Cannot recall directory: $symlink points to twin folder itself"
      exit 1
      ;;
    *)
      print_error "recall: Symlink does not point to twin folder: $symlink $ARROW_RX $abs_target"
      exit 1
      ;;
  esac
  
  # Check if target file actually exists
  if [[ ! -e "$abs_target" ]]; then
    print_error "recall: Target file does not exist in twin: $abs_target"
    exit 1
  fi
  
  # Check if target is readable/moveable
  if [[ ! -r "$abs_target" ]]; then
    print_error "recall: Cannot read target file: $abs_target"
    exit 1
  fi
  
  # Check if we can remove from twin directory
  local twin_parent
  twin_parent="$(dirname -- "$abs_target")"
  if [[ ! -w "$twin_parent" ]]; then
    print_error "recall: Cannot move file from twin: $twin_parent (no write permission)"
    exit 1
  fi
  
  # Check if symlink parent directory allows removal
  local symlink_dir
  symlink_dir="$(dirname -- "$symlink")"
  if [[ ! -w "$symlink_dir" ]]; then
    print_error "recall: Cannot remove symlink from: $symlink_dir (no write permission)"
    exit 1
  fi
  
  # Verbose progress output
  if [[ $verbose -eq 1 ]]; then
    printf "Recalling: %s%s%s\n" "$DIM" "$abs_target" "$RESET"
    printf "From twin: %s%s%s\n" "$DIM" "$TWIN" "$RESET"
    printf "To base:   %s%s%s\n" "$DIM" "$symlink" "$RESET"
    printf "Remove:    %s%s%s\n\n" "$DIM" "$symlink" "$RESET"
  fi
  
  # Remove the symlink first
  if rm -- "$symlink"; then
    if [[ $verbose -eq 1 ]]; then
      printf "%s%s%s Removed symlink: %s\n" "$GREEN" "$OK" "$RESET" "$symlink"
    fi
  else
    print_error "recall: Failed to remove symlink: $symlink"
    exit 1
  fi
  
  # Move the file from twin back to original location
  if mv -- "$abs_target" "$symlink"; then
    # Verbose summary
    if [[ $verbose -eq 1 ]]; then
      printf "%s%s%s Recalled $ARROW_LX %s\n" "$GREEN" "$OK" "$RESET" "$abs_target"
      printf "\n%s%s%s Done.\n" "$GREEN" "$OK" "$RESET"
    fi
    
    # Concise line (default): icon + filename + connection + X + name  
    if [[ $verbose -eq 0 ]]; then
      local name icon name_len connection_line
      name="$(basename "$symlink")"
      if [[ -d "$symlink" ]]; then
        icon="$FOLDER_ICON"
      else
        icon="$FILE_ICON"
      fi
      
      # Calculate max filename length for consistent alignment with reef-status
      name_len=${#name}
      [[ $name_len -lt 10 ]] && name_len=10
      connection_line=""
      for ((i=0; i<name_len; i++)); do
        connection_line+="$CONNECT_DASH"
      done
      
      printf "%s %-*s %s%s%s %s%s%s %s\n" "$icon" $name_len "$name" "$DOT" "$connection_line" "$DOT" "$RED" "$ERR" "$RESET" "$name"
    fi
  else
    print_error "recall: Move failed: $symlink $ARROW_LX $abs_target"
    
    # Attempt rollback: recreate the symlink
    if [[ $verbose -eq 1 ]]; then
      print_warning "recall: Attempting rollback..."
    fi
    
    set +e  # Allow ln to fail without exiting
    ln -s -- "$abs_target" "$symlink" 2>/dev/null
    rollback_status=$?
    set -e
    
    if [[ $rollback_status -eq 0 ]]; then
      if [[ $verbose -eq 1 ]]; then
        print_success "recall: Rollback successful: symlink restored at $symlink"
      fi
      exit 1
    else
      print_error "recall: Rollback failed! File is still at: $abs_target"
      print_error "recall: You may need to manually recreate symlink: $symlink $ARROW_RX $abs_target"
      exit 1
    fi
  fi
}

# =============================================================================
# SUBCOMMAND: UNPLUG
# =============================================================================

unplug_show_help() {
  cat <<EOF
reef unplug â€” remove symlinks in BASE that point into its twin folder

Usage:
  reef unplug [-v|--verbose]

Options:
  -v, --verbose    Show detailed output for each operation
  -h, --help       Show this help

Examples:
  reef unplug
  reef unplug --verbose

Notes:
  - Removes all symlinks in base directory that point to twin folder
  - Leaves other symlinks untouched
  - Works even if twin directory doesn't exist (removes orphaned links)
  - Requires write permission on base directory
EOF
}

cmd_unplug() {
  # Local variables for unplug subcommand
  local verbose=0
  local show_help=0
  local args=()
  
  # Parse unplug-specific arguments
  for arg in "$@"; do
    case "$arg" in
      -v|--verbose)
        verbose=1
        ;;
      -h|--help)
        show_help=1
        ;;
      -*)
        print_error "unplug: unknown option: $arg"
        printf "Run 'reef unplug --help' for usage information.\n" >&2
        exit 2
        ;;
      *)
        args+=("$arg")
        ;;
    esac
  done
  
  # Show help if requested
  if [[ $show_help -eq 1 ]]; then
    unplug_show_help
    exit 0
  fi
  
  # reef-unplug takes no positional arguments
  if [[ ${#args[@]} -ne 0 ]]; then
    print_error "unplug: unexpected arguments. reef unplug takes no positional arguments."
    printf "Usage: reef unplug [-v|--verbose]\n" >&2
    exit 2
  fi
  
  # BASE/TWIN should already be set by main() calling detect_base_twin()
  # Validate BASE exists
  if [[ ! -d "$BASE" ]]; then
    print_error "unplug: Base folder not found: $BASE"
    exit 1
  fi
  
  # Check write permissions on base directory
  if [[ ! -w "$BASE" ]]; then
    print_error "unplug: No write permission on base directory: $BASE"
    exit 1
  fi
  
  # If twin missing -> warn and continue (can still remove orphaned links)
  if [[ ! -d "$TWIN" ]]; then
    print_warning "unplug: Twin folder not found: $TWIN"
    printf "%sWill still check for orphaned links pointing to: %s%s\n\n" "$DIM" "$TWIN" "$RESET"
  fi
  
  if [[ $verbose -eq 1 ]]; then
    printf "Removing links from: %s%s%s\n" "$DIM" "$BASE" "$RESET"
    printf "That point to:       %s%s%s\n\n" "$DIM" "$TWIN" "$RESET"
  fi
  
  # Store original shell options
  local original_shopt
  original_shopt=$(shopt -p dotglob nullglob 2>/dev/null || true)
  shopt -s dotglob nullglob
  
  # Collect all symlinks first to calculate max length
  local all_names=()
  local dst name raw_target resolved_target
  
  for dst in "$BASE"/*; do
    name="$(basename -- "$dst")"
    [[ "$name" == "." || "$name" == ".." ]] && continue
    [[ -L "$dst" ]] || continue
    
    # Get the raw symlink target
    raw_target="$(readlink "$dst" 2>/dev/null || true)"
    if [[ -n "$raw_target" ]]; then
      # Resolve to absolute path
      if [[ "$raw_target" == /* ]]; then
        resolved_target="$raw_target"
      else
        resolved_target="$(_realpath "$(dirname -- "$dst")/$raw_target")"
      fi
      
      # Check if target is within twin directory
      case "$resolved_target" in
        "$TWIN"|"$TWIN"/*)
          all_names+=("$name")
          ;;
      esac
    fi
  done
  
  # Calculate maximum filename length for alignment
  local max_len=0 len
  if [[ ${#all_names[@]} -gt 0 ]]; then
    for name in "${all_names[@]}"; do
      len=${#name}
      [[ $len -gt $max_len ]] && max_len=$len
    done
  fi
  
  # Ensure minimum width for alignment
  [[ $max_len -lt 10 ]] && max_len=10
  
  # Calculate connection line length - fixed width based on longest filename
  local connection_line=""
  local i
  for ((i=0; i<max_len; i++)); do
    connection_line+="â•Œ"
  done
  
  local removed=0 checked_any=0 icon
  
  for dst in "$BASE"/*; do
    checked_any=1
    name="$(basename -- "$dst")"
    
    [[ "$name" == "." || "$name" == ".." ]] && continue
    [[ -L "$dst" ]] || continue

    # Get the raw symlink target
    raw_target="$(readlink "$dst" 2>/dev/null || true)"
    if [[ -z "$raw_target" ]]; then
      printf "%s%s%s %s %s(cannot read symlink)%s\n" "$RED" "$ERR" "$RESET" "$name" "$DIM" "$RESET"
      continue
    fi

    # Resolve to absolute path
    if [[ "$raw_target" == /* ]]; then
      # Already absolute
      resolved_target="$raw_target"
    else
      # Relative - resolve from the directory containing the symlink
      resolved_target="$(_realpath "$(dirname -- "$dst")/$raw_target")"
    fi

    # Determine if target is a file or folder
    if [[ -d "$resolved_target" ]]; then
      icon="$FOLDER_ICON"
    else
      icon="$FILE_ICON"
    fi

    # Check if target is within twin directory
    case "$resolved_target" in
      "$TWIN"|"$TWIN"/*)
        if [[ ! -e "$resolved_target" ]]; then
          if [[ $verbose -eq 1 ]]; then
            printf "%s%s%s %s %s(broken link to twin - removing)%s\n" "$YELLOW" "$WARN" "$RESET" "$name" "$DIM" "$RESET"
          fi
        fi
        
        if rm -f -- "$dst"; then
          # Verbose: detailed output
          if [[ $verbose -eq 1 ]]; then
            printf "%s%s%s %s\n" "$GREEN" "$OK" "$RESET" "$name"
          fi
          # Concise: show unlinked with fixed width visual
          if [[ $verbose -eq 0 ]]; then
            printf "%s%s%s %-*s %s%s%s %s %s\n" "$RED" "$ERR" "$RESET" $max_len "$name" "$DOT" "$connection_line" "$DOT" "$icon" "$name"
          fi
          removed=$((removed+1))
        else
          printf "%s%s%s %s %s(remove failed)%s\n" "$RED" "$ERR" "$RESET" "$name" "$DIM" "$RESET"
        fi
        ;;
      *) 
        # Not pointing to twin - leave it alone
        ;;
    esac
  done
  
  # Restore original shell options
  if [[ -n "$original_shopt" ]]; then
    eval "$original_shopt"
  else
    shopt -u dotglob nullglob 2>/dev/null || true
  fi
  
  if [[ $checked_any -eq 0 ]]; then
    printf "%sNothing to scan in: %s%s\n" "$DIM" "$BASE" "$RESET"
  fi
  
  # Summary only in verbose mode
  if [[ $verbose -eq 1 ]]; then
    printf "\nRemoved %d link(s).\n" "$removed"
  fi
}

# =============================================================================
# 8. MAIN DISPATCHER
# =============================================================================

main() {
  # Parse global arguments first
  parse_global_args "$@"
  
  # Handle global options
  if [[ $show_version -eq 1 ]]; then
    show_version
    exit 0
  fi
  
  if [[ $show_help -eq 1 ]]; then
    show_main_help
    exit 0
  fi
  
  # Handle no-args case (show help)
  if [[ ${#args[@]} -eq 0 ]]; then
    show_main_help
    exit 0
  fi
  
  # Initialize BASE/TWIN detection for subcommands
  detect_base_twin
  
  # Dispatch to subcommand
  local subcommand="${args[0]}"
  case "$subcommand" in
    kick)
      cmd_kick "${args[@]:1}"
      ;;
    status)
      cmd_status "${args[@]:1}"
      ;;
    plug)
      cmd_plug "${args[@]:1}"
      ;;
    recall)
      cmd_recall "${args[@]:1}"
      ;;
    unplug)
      cmd_unplug "${args[@]:1}"
      ;;
    *)
      print_error "Unknown subcommand: $subcommand"
      printf "\nRun 'reef --help' to see available subcommands.\n" >&2
      exit 2
      ;;
  esac
}

# Entry point
main "$@"
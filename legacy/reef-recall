#!/usr/bin/env bash
# reef-recall ‚Äî move a file from the twin folder back to base and remove its symlink.
# Usage:
#   reef-recall <symlink> [--suffix=-reef]
# Behavior:
#   - Check that the argument is a symlink pointing to the twin folder.
#   - Move the target file from twin back to the original location.
#   - Remove the symlink.

set -euo pipefail

# ----- Configuration -----  
SUFFIX="-reef"   # default twin suffix

# ----- Colors & symbols (fallback to plain if not a TTY) -----
is_tty=0
if [ -t 1 ]; then is_tty=1; fi

if [ "$is_tty" -eq 1 ]; then
  RED="$(printf '\033[31m')"
  GREEN="$(printf '\033[32m')"
  YELLOW="$(printf '\033[33m')"
  DIM="$(printf '\033[2m')"
  BOLD="$(printf '\033[1m')"
  RESET="$(printf '\033[0m')"
  OK="‚úì"
  ERR="‚úó"
  DOT="‚óè"
  ARROW_RX="‚Üí"
  ARROW_LX="‚Üê"
  CONNECT="‚îÅ"
  WARN="‚ö†Ô∏è"
  FILE_ICON="üìÑ"
  FOLDER_ICON="üìÅ"
  LINK_ICON="üîó"
else
  RED=""; GREEN=""; YELLOW=""; DIM=""; BOLD=""; RESET=""
  OK="[OK]"; ERR="[ERR]"; DOT="*"; ARROW_RX="->"; ARROW_LX="<-"; CONNECT="-"; WARN="[WARN]"; FILE_ICON="[F]"; FOLDER_ICON="[D]"; LINK_ICON="[L]"
fi

# Parse arguments
verbose=0
args=()

for arg in "$@"; do
  case "$arg" in
    -v|--verbose) verbose=1 ;;
    --suffix=*) SUFFIX="${arg#*=}" ;;
    -h|--help)
      cat <<EOF
reef-recall ‚Äî move a file from the twin folder back to base and remove its symlink

Usage:
  reef-recall [-v|--verbose] [--suffix=SUFFIX] <symlink>

Options:
  -v, --verbose    Show detailed output for each operation
  --suffix=SUFFIX  Use custom twin suffix (default: -reef)
  -h, --help       Show this help

Examples:
  reef-recall myfile
  reef-recall --verbose config/settings.json
  reef-recall --suffix=-experiment myfile
EOF
      exit 0
      ;;
    -*) 
      printf "%s%s%s Error: unknown option: %s\n" "$RED" "$ERR" "$RESET" "$arg" >&2
      exit 2
      ;;
    *)
      args+=("$arg")
      ;;
  esac
done

# Check for required symlink argument
if [ "${#args[@]}" -eq 0 ]; then
  printf "%s%s%s Error: missing required argument <symlink>\n" "$RED" "$ERR" "$RESET" >&2
  printf "%s%s%s Usage: reef-recall [-v|--verbose] [--suffix=SUFFIX] <symlink>\n" "$YELLOW" "$DOT" "$RESET" >&2
  exit 2
elif [ "${#args[@]}" -gt 1 ]; then
  printf "%s%s%s Error: too many arguments. Expected 1 symlink, got %d\n" "$RED" "$ERR" "$RESET" "${#args[@]}" >&2
  printf "%s%s%s Usage: reef-recall [-v|--verbose] [--suffix=SUFFIX] <symlink>\n" "$YELLOW" "$DOT" "$RESET" >&2
  exit 2
fi

SYMLINK_ARG="${args[0]}"

# Practical realpath that works for our use case
_realpath() {
  local path="$1"
  
  # Use system realpath with fallback to manual resolution
  if command -v realpath >/dev/null 2>&1; then
    realpath -m "$path" 2>/dev/null || echo "$path"
  else
    # Make absolute if relative
    if [[ "$path" != /* ]]; then
      path="$PWD/$path"
    fi
    
    # Basic cleanup
    path="${path//\/\///}"  # compress multiple slashes
    path="${path%/}"        # remove trailing slash
    [[ -n "$path" ]] || path="/"
    
    echo "$path"
  fi
}

# Determine BASE and TWIN from current dir with improved logic
CWD="$(_realpath "$PWD")"
BASE=""
TWIN=""

# Check if current directory ends with suffix AND a non-suffix version exists
if [[ "$CWD" == *"$SUFFIX" ]]; then
 potential_base="${CWD%$SUFFIX}"
 # Only treat as twin if the base actually exists
 if [[ -d "$potential_base" ]]; then
   TWIN="$CWD"
   BASE="$(_realpath "$potential_base")"
 fi
fi

# If we haven't identified BASE/TWIN yet, assume we're in base
if [[ -z "$BASE" ]]; then
 BASE="$CWD"
 TWIN="$(_realpath "${CWD}${SUFFIX}")"
fi

# Sanity check: BASE and TWIN shouldn't be the same
if [[ "$BASE" == "$TWIN" ]]; then
 printf "%s%s%s Base and twin directories are identical. Check your suffix configuration.\n" "$RED" "$ERR" "$RESET" >&2
 exit 1
fi

# Base must exist
if [[ ! -d "$BASE" ]]; then
 printf "%s%s%s Base folder not found: %s\n" "$RED" "$ERR" "$RESET" "$BASE" >&2
 exit 1
fi

# Check write permissions on base directory
if [[ ! -w "$BASE" ]]; then
 printf "%s%s%s No write permission on base directory: %s\n" "$RED" "$ERR" "$RESET" "$BASE" >&2
 exit 1
fi

# Twin folder missing ‚Üí error, can't recall from non-existent twin
if [[ ! -d "$TWIN" ]]; then
 printf "%s%s%s Twin folder not found: %s\n" "$RED" "$ERR" "$RESET" "$TWIN" >&2
 exit 1
fi

# Check write permissions on twin directory
if [[ ! -w "$TWIN" ]]; then
 printf "%s%s%s No write permission on twin directory: %s\n" "$RED" "$ERR" "$RESET" "$TWIN" >&2
 exit 1
fi

# Resolve symlink path
if [[ "$SYMLINK_ARG" = /* ]]; then
 SYMLINK="$SYMLINK_ARG"
else
 SYMLINK="$PWD/$SYMLINK_ARG"
fi
SYMLINK="$(_realpath "$SYMLINK")"

# Validations
if [[ ! -e "$SYMLINK" && ! -L "$SYMLINK" ]]; then
 printf "%s%s%s No such file or symlink: %s\n" "$RED" "$ERR" "$RESET" "$SYMLINK" >&2
 exit 1
fi

# Must be a symlink
if [[ ! -L "$SYMLINK" ]]; then
 printf "%s%s%s Not a symlink: %s\n" "$RED" "$ERR" "$RESET" "$SYMLINK" >&2
 exit 1
fi

# Get the symlink target
TARGET="$(readlink "$SYMLINK" 2>/dev/null || true)"
if [[ -z "$TARGET" ]]; then
 printf "%s%s%s Cannot read symlink target: %s\n" "$RED" "$ERR" "$RESET" "$SYMLINK" >&2
 exit 1
fi

# Resolve target to absolute path if it's relative
if [[ "$TARGET" == /* ]]; then
 # Already absolute
 ABS_TARGET="$TARGET"
else
 # Relative - resolve from the directory containing the symlink
 ABS_TARGET="$(_realpath "$(dirname -- "$SYMLINK")/$TARGET")"
fi

# Check if target is actually in the twin directory
case "$ABS_TARGET" in
 "$TWIN"/*)
   # Good, it's in the twin
   ;;
 "$TWIN")
   # Edge case: symlink points directly to twin directory
   printf "%s%s%s Cannot recall directory: %s points to twin folder itself\n" "$RED" "$ERR" "$RESET" "$SYMLINK" >&2
   exit 1
   ;;
 *)
   printf "%s%s%s Symlink does not point to twin folder: %s %s %s\n" "$RED" "$ERR" "$RESET" "$SYMLINK" "$ARROW_RX" "$ABS_TARGET" >&2
   exit 1
   ;;
esac

# Check if target file actually exists
if [[ ! -e "$ABS_TARGET" ]]; then
 printf "%s%s%s Target file does not exist in twin: %s\n" "$RED" "$ERR" "$RESET" "$ABS_TARGET" >&2
 exit 1
fi

# Check if target is readable/moveable
if [[ ! -r "$ABS_TARGET" ]]; then
 printf "%s%s%s Cannot read target file: %s\n" "$RED" "$ERR" "$RESET" "$ABS_TARGET" >&2
 exit 1
fi

# Check if we can remove from twin directory
TWIN_PARENT="$(dirname -- "$ABS_TARGET")"
if [[ ! -w "$TWIN_PARENT" ]]; then
 printf "%s%s%s Cannot move file from twin: %s (no write permission)\n" "$RED" "$ERR" "$RESET" "$TWIN_PARENT" >&2
 exit 1
fi

# Check if symlink parent directory allows removal
SYMLINK_DIR="$(dirname -- "$SYMLINK")"
if [[ ! -w "$SYMLINK_DIR" ]]; then
 printf "%s%s%s Cannot remove symlink from: %s (no write permission)\n" "$RED" "$ERR" "$RESET" "$SYMLINK_DIR" >&2
 exit 1
fi

if [ "$verbose" -eq 1 ]; then
  printf "Recalling: %s%s%s\n" "$DIM" "$ABS_TARGET" "$RESET"
  printf "From twin: %s%s%s\n" "$DIM" "$TWIN" "$RESET"
  printf "To base:   %s%s%s\n" "$DIM" "$SYMLINK" "$RESET"
  printf "Remove:    %s%s%s\n\n" "$DIM" "$SYMLINK" "$RESET"
fi

# Remove the symlink first
if rm -- "$SYMLINK"; then
 if [ "$verbose" -eq 1 ]; then
   printf "%s%s%s Removed symlink: %s\n" "$GREEN" "$OK" "$RESET" "$SYMLINK"
 fi
else
 printf "%s%s%s Failed to remove symlink: %s\n" "$RED" "$ERR" "$RESET" "$SYMLINK" >&2
 exit 1
fi

# Move the file from twin back to original location
if mv -- "$ABS_TARGET" "$SYMLINK"; then
  # Verbose summary
  if [ "$verbose" -eq 1 ]; then
    printf "%s%s%s Recalled ‚Üê %s\n" "$GREEN" "$OK" "$RESET" "$ABS_TARGET"
    printf "\n%s%s%s Done.\n" "$GREEN" "$OK" "$RESET"
  fi
  # Concise line (default): icon + filename + connection + X + name  
  if [ "$verbose" -eq 0 ]; then
    name="$(basename "$SYMLINK")"
    if [ -d "$SYMLINK" ]; then icon="$FOLDER_ICON"; else icon="$FILE_ICON"; fi
    
    # Calculate max filename length for consistent alignment with reef-status
    name_len=${#name}
    [[ $name_len -lt 10 ]] && name_len=10
    connection_line=""
    for ((i=0; i<name_len; i++)); do
      connection_line+="‚ïå"
    done
    
    printf "%s %-*s ‚óè%s‚óã %s‚úó%s %s\n" "$icon" $name_len "$name" "$connection_line" "$RED" "$RESET" "$name"
  fi
else
 printf "%s%s%s Move failed: %s %s %s\n" "$RED" "$ERR" "$RESET" "$SYMLINK" "$ARROW_LX" "$ABS_TARGET" >&2
 
 # Attempt rollback: recreate the symlink
 if [ "$verbose" -eq 1 ]; then
   printf "%s%s%s Attempting rollback...\n" "$YELLOW" "$WARN" "$RESET"
 fi
 if ln -s -- "$ABS_TARGET" "$SYMLINK" 2>/dev/null; then
   if [ "$verbose" -eq 1 ]; then
     printf "%s%s%s Rollback successful: symlink restored at %s\n" "$GREEN" "$OK" "$RESET" "$SYMLINK"
   fi
   exit 1
 else
   printf "%s%s%s Rollback failed! File is still at: %s\n" "$RED" "$ERR" "$RESET" "$ABS_TARGET" >&2
   printf "%s%s%s You may need to manually recreate symlink: %s %s %s\n" "$RED" "$ERR" "$RESET" "$SYMLINK" "$ARROW_RX" "$ABS_TARGET" >&2
   exit 1
 fi
fi

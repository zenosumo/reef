#!/usr/bin/env bash
# reef-kick — move a file/dir from BASE into the TWIN folder and replace it with a symlink.
# Usage:
#   reef-kick [-v|--verbose] <path-inside-project>
# Behavior:
#   - Run from either BASE or its SUFFIX twin.
#   - If TWIN doesn't exist, interactively offer to create it (default: Yes on Enter).
#   - Refuse if the target already exists in TWIN.
#   - Move the source, then create a symlink at the original location pointing to TWIN.
# Output:
#   - Default: concise line consistent with reef-status (single green line on success).
#   - Verbose (-v/--verbose): detailed multi-line progress output (old style).
#   - Always prints clear error lines on failure and returns non-zero.

set -euo pipefail

# ----- Configuration -----
SUFFIX="-reef"

# ----- Colors & symbols (fallback to plain if not a TTY) -----
is_tty=0
if [ -t 1 ]; then is_tty=1; fi

if [ "$is_tty" -eq 1 ]; then
  RED="$(printf '\033[31m')"
  GREEN="$(printf '\033[32m')"
  YELLOW="$(printf '\033[33m')"
  DIM="$(printf '\033[2m')"
  BOLD="$(printf '\033[1m')"
  RESET="$(printf '\033[0m')"
  OK="✓"
  ERR="✗"
  DOT="●"
  ARROW_RX="→"
  ARROW_LX="←"
  CONNECT="━"
  FILE_ICON="📄"
  FOLDER_ICON="📁"
  LINK_ICON="🔗"
else
  RED=""; GREEN=""; YELLOW=""; DIM=""; BOLD=""; RESET=""
  OK="[OK]"; ERR="[ERR]"; DOT="*"; ARROW_RX="->"; ARROW_LX="<-"; CONNECT="-"
  FILE_ICON="[F]"; FOLDER_ICON="[D]"; LINK_ICON="[L]"
fi


# Practical realpath that works for our use case
_realpath() {
  local path="$1"
  
  # Use system realpath with fallback to manual resolution
  if command -v realpath >/dev/null 2>&1; then
    realpath -m "$path" 2>/dev/null || echo "$path"
  else
    # Make absolute if relative
    if [[ "$path" != /* ]]; then
      path="$PWD/$path"
    fi
    
    # Basic cleanup
    path="${path//\/\///}"  # compress multiple slashes
    path="${path%/}"        # remove trailing slash
    [[ -n "$path" ]] || path="/"
    
    echo "$path"
  fi
}
verbose=0
args=()

for arg in "$@"; do
  case "$arg" in
    -v|--verbose) verbose=1 ;;
    -h|--help)
      cat <<EOF
reef-kick — move a file/dir into the $SUFFIX twin and link it back

Usage:
  reef-kick [-v|--verbose] <path-inside-project>

Examples:
  reef-kick src/index.ts
  reef-kick --verbose config

Notes:
  - Run inside your project BASE or its "$SUFFIX" twin directory.
  - If the twin directory doesn't exist, you'll be asked to create it.
EOF
      exit 0
      ;;
    -*)
      printf "%s%s Error:%s unknown option: %s\n" "$RED" "$ERR" "$RESET" "$arg" >&2
      exit 2
      ;;
    *)
      args+=("$arg")
      ;;
  esac
done

if [ "${#args[@]}" -eq 0 ]; then
  printf "%s%s%s Error: missing required argument <path-inside-project>\n" "$RED" "$ERR" "$RESET" >&2
  printf "%s%s%s Usage: reef-kick [-v|--verbose] <path-inside-project>\n" "$YELLOW" "$DOT" "$RESET" >&2
  exit 2
elif [ "${#args[@]}" -gt 1 ]; then
  printf "%s%s%s Error: too many arguments. Expected 1 path, got %d\n" "$RED" "$ERR" "$RESET" "${#args[@]}" >&2
  printf "%s%s%s Usage: reef-kick [-v|--verbose] <path-inside-project>\n" "$YELLOW" "$DOT" "$RESET" >&2
  exit 2
fi

# Determine BASE and TWIN from current dir with improved logic
CWD="$(_realpath "$PWD")"
BASE=""
TWIN=""

# Check if current directory ends with suffix AND a non-suffix version exists
if [[ "$CWD" == *"$SUFFIX" ]]; then
  potential_base="${CWD%$SUFFIX}"
  # Only treat as twin if the base actually exists
  if [[ -d "$potential_base" ]]; then
    TWIN="$CWD"
    BASE="$(_realpath "$potential_base")"
  fi
fi

# If we haven't identified BASE/TWIN yet, assume we're in base
if [[ -z "$BASE" ]]; then
  BASE="$CWD"
  TWIN="${CWD}${SUFFIX}"
fi

# Sanity check: BASE and TWIN shouldn't be the same
if [[ "$BASE" == "$TWIN" ]]; then
  printf "%s%s Error:%s Base and twin directories are identical. Check your suffix configuration.\n" "$RED" "$ERR" "$RESET" >&2
  exit 1
fi

REL_PATH="${args[0]}"
SRC="$BASE/$REL_PATH"
DEST="$TWIN/$REL_PATH"

# ----- Helpers -----

ask_yes_default_yes() {
  # prints prompt to stderr, reads from tty if available
  local prompt="$1"
  local reply
  if [ -t 0 ]; then
    read -r -p "$prompt [Y/n] " reply
  else
    reply="y"
  fi
  case "$reply" in
    [nN]*) return 1 ;;
    *) return 0 ;;
  esac
}

# ----- Guards -----
if [ ! -e "$SRC" ]; then
  printf "%s%s Error:%s not found: %s\n" "$RED" "$ERR" "$RESET" "$SRC" >&2
  exit 1
fi

# Must not already be a symlink pointing to twin
if [ -L "$SRC" ]; then
  link_target="$(readlink "$SRC")"
  # Normalize relative link target to absolute for comparison
  if [[ "$link_target" != /* ]]; then
    link_target="$(cd "$(dirname "$SRC")" && realpath -m "$link_target")"
  fi
  # Compute absolute intended destination
  abs_dest="$(cd "$TWIN" 2>/dev/null && _realpath "$DEST" 2>/dev/null || echo "$DEST")"
  if [ "$link_target" = "$abs_dest" ]; then
    printf "%s%s Already linked:%s %s %s %s\n" "$YELLOW" "$DOT" "$RESET" "$SRC" "$ARROW_RX" "$DEST" >&2
    exit 1
  fi
fi

# Ensure twin exists (or create)
if [ ! -d "$TWIN" ]; then
  if ask_yes_default_yes "Twin folder does not exist. Create it at: $TWIN?"; then
    mkdir -p "$TWIN"
    if [ "$verbose" -eq 1 ]; then
      printf "Created twin: %s\n" "$TWIN"
    fi
  else
    printf "%s%s Aborted:%s twin folder missing: %s\n" "$RED" "$ERR" "$RESET" "$TWIN" >&2
    exit 1
  fi
fi

# Refuse if destination exists
if [ -e "$DEST" ]; then
  printf "%s%s Error:%s target already exists in twin: %s\n" "$RED" "$ERR" "$RESET" "$DEST" >&2
  exit 1
fi

# ----- Action -----
if [ "$verbose" -eq 1 ]; then
  printf "Moving:    %s%s%s\n" "$DIM" "$SRC" "$RESET"
  printf "To twin:   %s%s%s\n" "$DIM" "$DEST" "$RESET"
  printf "Link back: %s%s%s\n\n" "$DIM" "$SRC" "$RESET"
fi

# Ensure parent dir in twin
mkdir -p "$(dirname "$DEST")"

# Move then link; on failure, attempt rollback
tmp_rollback=""
set +e
mv "$SRC" "$DEST"
mv_status=$?
if [ $mv_status -ne 0 ]; then
  printf "%s%s Error:%s failed to move %s to %s\n" "$RED" "$ERR" "$RESET" "$SRC" "$DEST" >&2
  exit 1
fi

ln -s "$(_realpath "$DEST")" "$SRC"
ln_status=$?
if [ $ln_status -ne 0 ]; then
  # rollback move
  mv "$DEST" "$SRC" 2>/dev/null
  printf "%s%s Error:%s failed to create symlink. Rolled back.\n" "$RED" "$ERR" "$RESET" >&2
  exit 1
fi
set -e

# ----- Output -----
if [ "$verbose" -eq 1 ]; then
  printf "%s%s%s Moved %s → %s\n" "$GREEN" "$OK" "$RESET" "$SRC" "$DEST"
  printf "%s%s%s Linked %s → %s\n" "$GREEN" "$OK" "$RESET" "$SRC" "$DEST"
  printf "\n%s%s%s Done.\n" "$GREEN" "$OK" "$RESET"
else
  # Concise, reef-status-like with fixed-width connection
  rel_src="$REL_PATH"
  rel_dest="$REL_PATH"
  base_name_only="$(basename "$BASE")"
  twin_name_only="$(basename "$TWIN")"
  
  # Determine if it's a file or folder
  if [ -d "$DEST" ]; then
    icon="$FOLDER_ICON"
  else
    icon="$FILE_ICON"
  fi
  
  # Calculate connection line length based on filename length (like reef-status)
  name_len=${#rel_src}
  [[ $name_len -lt 10 ]] && name_len=10
  connection_line=""
  for ((i=0; i<name_len; i++)); do
    connection_line+="━"
  done
  
  printf "🔗 %-*s ●%s▶ %s %s/%s\n" $name_len "$rel_src" "$connection_line" "$icon" "$twin_name_only" "$rel_dest"
fi

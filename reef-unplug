#!/usr/bin/env bash
# reef-unplug — remove symlinks in BASE that point into its twin folder (configurable suffix)

set -euo pipefail

# ----- Configuration -----
SUFFIX="-reef"   # default twin suffix

# ----- Colors & symbols (fallback to plain if not a TTY) -----
is_tty=0
if [ -t 1 ]; then is_tty=1; fi

if [ "$is_tty" -eq 1 ]; then
  RED="$(printf '\033[31m')"
  GREEN="$(printf '\033[32m')"
  YELLOW="$(printf '\033[33m')"
  DIM="$(printf '\033[2m')"
  BOLD="$(printf '\033[1m')"
  RESET="$(printf '\033[0m')"
  OK="✓"
  ERR="✗"
  DOT="●"
  ARROW_RX="→"
  ARROW_LX="←"
  CONNECT="━"
  WARN="⚠️"
  FILE_ICON="📄"
  FOLDER_ICON="📁"
  LINK_ICON="🔗"
else
  RED=""; GREEN=""; YELLOW=""; DIM=""; BOLD=""; RESET=""
  OK="[OK]"; ERR="[ERR]"; DOT="*"; ARROW_RX="->"; ARROW_LX="<-"; CONNECT="-"; WARN="[WARN]"; FILE_ICON="[F]"; FOLDER_ICON="[D]"; LINK_ICON="[L]"
fi

# Parse arguments
verbose=0
args=()

for arg in "$@"; do
  case "$arg" in
    -v|--verbose) verbose=1 ;;
    --suffix=*) SUFFIX="${arg#*=}" ;;
    -h|--help)
      cat <<EOF
reef-unplug — remove symlinks in BASE that point into its twin folder

Usage:
  reef-unplug [-v|--verbose] [--suffix=SUFFIX]

Options:
  -v, --verbose    Show detailed output for each operation
  --suffix=SUFFIX  Use custom twin suffix (default: -reef)
  -h, --help       Show this help

Examples:
  reef-unplug
  reef-unplug --verbose
  reef-unplug --suffix=-experiment
EOF
      exit 0
      ;;
    -*)
      printf "%s%s%s Error: unknown option: %s\n" "$RED" "$ERR" "$RESET" "$arg" >&2
      exit 2
      ;;
    *)
      args+=("$arg")
      ;;
  esac
done

# Practical realpath that works for our use case
_realpath() {
  local path="$1"
  
  # Use system realpath with fallback to manual resolution
  if command -v realpath >/dev/null 2>&1; then
    realpath -m "$path" 2>/dev/null || echo "$path"
  else
    # Make absolute if relative
    if [[ "$path" != /* ]]; then
      path="$PWD/$path"
    fi
    
    # Basic cleanup
    path="${path//\/\///}"  # compress multiple slashes
    path="${path%/}"        # remove trailing slash
    [[ -n "$path" ]] || path="/"
    
    echo "$path"
  fi
}

# Determine BASE and TWIN from current dir with improved logic
CWD="$(_realpath "$PWD")"
BASE=""
TWIN=""

# Check if current directory ends with suffix AND a non-suffix version exists
if [[ "$CWD" == *"$SUFFIX" ]]; then
  potential_base="${CWD%$SUFFIX}"
  # Only treat as twin if the base actually exists
  if [[ -d "$potential_base" ]]; then
    TWIN="$CWD"
    BASE="$(_realpath "$potential_base")"
  fi
fi

# If we haven't identified BASE/TWIN yet, assume we're in base
if [[ -z "$BASE" ]]; then
  BASE="$CWD"
  TWIN="$(_realpath "${CWD}${SUFFIX}")"
fi

# Sanity check: BASE and TWIN shouldn't be the same
if [[ "$BASE" == "$TWIN" ]]; then
  printf "%s%s%s Base and twin directories are identical. Check your suffix configuration.\n" "$RED" "$ERR" "$RESET" >&2
  exit 1
fi

# Base must exist
if [[ ! -d "$BASE" ]]; then
  printf "%s%s%s Base folder not found: %s\n" "$RED" "$ERR" "$RESET" "$BASE" >&2
  exit 1
fi

# Check write permissions on base directory
if [[ ! -w "$BASE" ]]; then
  printf "%s%s%s No write permission on base directory: %s\n" "$RED" "$ERR" "$RESET" "$BASE" >&2
  exit 1
fi

# If twin missing -> warn and exit gracefully
if [[ ! -d "$TWIN" ]]; then
  printf "%s%s%s Twin folder not found: %s\n" "$YELLOW" "$WARN" "$RESET" "$TWIN"
  printf "%sWill still check for orphaned links pointing to: %s%s\n\n" "$DIM" "$TWIN" "$RESET"
fi

if [ "$verbose" -eq 1 ]; then
  printf "Removing links from: %s%s%s\n" "$DIM" "$BASE" "$RESET"
  printf "That point to:       %s%s%s\n\n" "$DIM" "$TWIN" "$RESET"
fi

# Store original shell options
original_shopt=$(shopt -p dotglob nullglob 2>/dev/null || true)

shopt -s dotglob nullglob

# Collect all symlinks first to calculate max length
all_names=()
for dst in "$BASE"/*; do
  name="$(basename -- "$dst")"
  [[ "$name" == "." || "$name" == ".." ]] && continue
  [[ -L "$dst" ]] || continue
  
  # Get the raw symlink target
  raw_target="$(readlink "$dst" 2>/dev/null || true)"
  if [[ -n "$raw_target" ]]; then
    # Resolve to absolute path
    if [[ "$raw_target" == /* ]]; then
      resolved_target="$raw_target"
    else
      resolved_target="$(_realpath "$(dirname -- "$dst")/$raw_target")"
    fi
    
    # Check if target is within twin directory
    case "$resolved_target" in
      "$TWIN"|"$TWIN"/*)
        all_names+=("$name")
        ;;
    esac
  fi
done

# Calculate maximum filename length for alignment
max_len=0
if [[ ${#all_names[@]} -gt 0 ]]; then
  for name in "${all_names[@]}"; do
    len=${#name}
    [[ $len -gt $max_len ]] && max_len=$len
  done
fi

# Ensure minimum width for alignment
[[ $max_len -lt 10 ]] && max_len=10

# Calculate connection line length - fixed width based on longest filename
connection_line=""
for ((i=0; i<max_len; i++)); do
  connection_line+="╌"
done

removed=0
checked_any=0

for dst in "$BASE"/*; do
  checked_any=1
  name="$(basename -- "$dst")"
  
  [[ "$name" == "." || "$name" == ".." ]] && continue
  [[ -L "$dst" ]] || continue

  # Get the raw symlink target
  raw_target="$(readlink "$dst" 2>/dev/null || true)"
  if [[ -z "$raw_target" ]]; then
    printf "%s%s%s %s %s(cannot read symlink)%s\n" "$RED" "$ERR" "$RESET" "$name" "$DIM" "$RESET"
    continue
  fi

  # Resolve to absolute path
  if [[ "$raw_target" == /* ]]; then
    # Already absolute
    resolved_target="$raw_target"
  else
    # Relative - resolve from the directory containing the symlink
    resolved_target="$(_realpath "$(dirname -- "$dst")/$raw_target")"
  fi

  # Determine if target is a file or folder
  if [[ -d "$resolved_target" ]]; then
    icon="$FOLDER_ICON"
  else
    icon="$FILE_ICON"
  fi

  # Check if target is within twin directory
  case "$resolved_target" in
    "$TWIN"|"$TWIN"/*)
      if [[ ! -e "$resolved_target" ]]; then
        if [ "$verbose" -eq 1 ]; then
          printf "%s%s%s %s %s(broken link to twin - removing)%s\n" "$YELLOW" "$WARN" "$RESET" "$name" "$DIM" "$RESET"
        fi
      fi
      
      if rm -f -- "$dst"; then
        # Verbose: detailed output
        if [ "$verbose" -eq 1 ]; then
          printf "%s%s%s %s\n" "$GREEN" "$OK" "$RESET" "$name"
        fi
        # Concise: show unlinked with fixed width visual
        if [ "$verbose" -eq 0 ]; then
          printf "%s%s%s %-*s ○%s● %s %s\n" "$RED" "$ERR" "$RESET" $max_len "$name" "$connection_line" "$icon" "$name"
        fi
        removed=$((removed+1))
      else
        printf "%s%s%s %s %s(remove failed)%s\n" "$RED" "$ERR" "$RESET" "$name" "$DIM" "$RESET"
      fi
      ;;
    *) 
      # Not pointing to twin - leave it alone
      ;;
  esac
done

# Restore original shell options
if [[ -n "$original_shopt" ]]; then
  eval "$original_shopt"
else
  shopt -u dotglob nullglob 2>/dev/null || true
fi

if [[ $checked_any -eq 0 ]]; then
  printf "%sNothing to scan in: %s%s\n" "$DIM" "$BASE" "$RESET"
fi

# Summary only in verbose mode
if [ "$verbose" -eq 1 ]; then
  printf "\nRemoved %d link(s).\n" "$removed"
fi

#!/usr/bin/env bash
# reef-plug — link files/dirs from the twin folder into the base folder.
# Usage: run from either the base project dir or its twin (default suffix "-reef").

set -euo pipefail

# ----- Configuration -----
SUFFIX="-reef"   # default twin suffix

# ----- Colors & symbols (fallback to plain if not a TTY) -----
is_tty=0
if [ -t 1 ]; then is_tty=1; fi

if [ "$is_tty" -eq 1 ]; then
  RED="$(printf '\033[31m')"
  GREEN="$(printf '\033[32m')"
  YELLOW="$(printf '\033[33m')"
  DIM="$(printf '\033[2m')"
  BOLD="$(printf '\033[1m')"
  RESET="$(printf '\033[0m')"
  OK="✓"
  ERR="✗"
  DOT="●"
  ARROW_RX="→"
  ARROW_LX="←"
  CONNECT="━"
  WARN="⚠️"
  FILE_ICON="📄"
  FOLDER_ICON="📁"
  LINK_ICON="🔗"
else
  RED=""; GREEN=""; YELLOW=""; DIM=""; BOLD=""; RESET=""
  OK="[OK]"; ERR="[ERR]"; DOT="*"; ARROW_RX="->"; ARROW_LX="<-"; CONNECT="-"; WARN="[WARN]"; FILE_ICON="[F]"; FOLDER_ICON="[D]"; LINK_ICON="[L]"
fi

# Parse arguments
verbose=0
args=()

for arg in "$@"; do
  case "$arg" in
    -v|--verbose) verbose=1 ;;
    --suffix=*) SUFFIX="${arg#*=}" ;;
    -h|--help)
      cat <<EOF
reef-plug — link files/dirs from the twin folder into the base folder

Usage:
  reef-plug [-v|--verbose] [--suffix=SUFFIX]

Options:
  -v, --verbose    Show detailed output for each operation
  --suffix=SUFFIX  Use custom twin suffix (default: -reef)
  -h, --help       Show this help

Examples:
  reef-plug
  reef-plug --verbose
  reef-plug --suffix=-experiment
EOF
      exit 0
      ;;
    -*)
      printf "%s%s%s Error: unknown option: %s\n" "$RED" "$ERR" "$RESET" "$arg" >&2
      exit 2
      ;;
    *)
      args+=("$arg")
      ;;
  esac
done

# Portable realpath (works on macOS/BSD and Linux). Resolves to absolute path.
_realpath() {
  local path="$1"
  
  # Use system realpath with fallback to manual resolution
  if command -v realpath >/dev/null 2>&1; then
    realpath -m "$path" 2>/dev/null || echo "$path"
  else
    # Make absolute if relative
    if [[ "$path" != /* ]]; then
      path="$PWD/$path"
    fi
    
    # Basic cleanup
    path="${path//\/\///}"  # compress multiple slashes
    path="${path%/}"        # remove trailing slash
    [[ -n "$path" ]] || path="/"
    
    echo "$path"
  fi
}

# Figure out BASE and TWIN with better logic
CWD="$(_realpath "$PWD")"
BASE=""
TWIN=""

# Check if current directory ends with suffix AND a non-suffix version exists
if [[ "$CWD" == *"$SUFFIX" ]]; then
  potential_base="${CWD%$SUFFIX}"
  # Only treat as twin if the base actually exists
  if [[ -d "$potential_base" ]]; then
    TWIN="$CWD"
    BASE="$(_realpath "$potential_base")"
  fi
fi

# If we haven't identified BASE/TWIN yet, assume we're in base
if [[ -z "$BASE" ]]; then
  BASE="$CWD"
  TWIN="${CWD}${SUFFIX}"
fi

# Sanity check: BASE and TWIN shouldn't be the same
if [[ "$BASE" == "$TWIN" ]]; then
  printf "%s%s%s Base and twin directories are identical. Check your suffix configuration.\n" "$RED" "$ERR" "$RESET" >&2
  exit 1
fi

# Base folder must exist
if [[ ! -d "$BASE" ]]; then
  printf "%s%s%s Base folder not found: %s\n" "$RED" "$ERR" "$RESET" "$BASE" >&2
  exit 1
fi

# Twin folder missing → yellow warning, quit gracefully  
if [[ ! -d "$TWIN" ]]; then
  printf "%s%s%s Twin '%s' folder not found: %s\n" "$YELLOW" "$WARN" "$RESET" "$SUFFIX" "$TWIN"
  exit 0
fi

# Check write permissions on base directory
if [[ ! -w "$BASE" ]]; then
  printf "%s%s%s No write permission on base directory: %s\n" "$RED" "$ERR" "$RESET" "$BASE" >&2
  exit 1
fi

if [ "$verbose" -eq 1 ]; then
  printf "Linking from: %s%s%s\n" "$DIM" "$TWIN" "$RESET"
  printf "Into base:    %s%s%s\n\n" "$DIM" "$BASE" "$RESET"
fi

# Store original shell options
original_shopt=$(shopt -p dotglob nullglob 2>/dev/null || true)

# Collect all filenames first to calculate max length
shopt -s dotglob nullglob
all_names=()
for src in "$TWIN"/*; do
  name="$(basename -- "$src")"
  [[ "$name" == "." || "$name" == ".." ]] && continue
  all_names+=("$name")
done

# Calculate maximum filename length for alignment
max_len=0
if [[ ${#all_names[@]} -gt 0 ]]; then
  for name in "${all_names[@]}"; do
    len=${#name}
    [[ $len -gt $max_len ]] && max_len=$len
  done
fi

# Ensure minimum width for alignment
[[ $max_len -lt 10 ]] && max_len=10

# Calculate connection line length - fixed width based on longest filename
connection_line=""
for ((i=0; i<max_len; i++)); do
  connection_line+="━"
done

# Link each top-level item from TWIN into BASE
created=0
had_any=0

for src in "$TWIN"/*; do
  had_any=1
  name="$(basename -- "$src")"
  dst="$BASE/$name"

  [[ "$name" == "." || "$name" == ".." ]] && continue

  # Determine if it's a file or folder
  if [[ -d "$src" ]]; then
    icon="$FOLDER_ICON"
  else
    icon="$FILE_ICON"
  fi

  if [[ -L "$dst" ]]; then
    # Check if it's pointing to our twin (idempotent behavior)
    if [[ "$(readlink "$dst")" == "$src" ]]; then
      if [ "$verbose" -eq 1 ]; then
        printf "%s%s%s %s %s(already linked correctly)%s\n" "$DIM" "$OK" "$RESET" "$name" "$DIM" "$RESET"
      fi
      # Concise: show already linked with fixed width
      if [ "$verbose" -eq 0 ]; then
        printf "%s %-*s %s%s%s %s %s\n" "$LINK_ICON" $max_len "$name" "$DOT" "$connection_line" "$DOT" "$icon" "$name"
      fi
    else
      printf "%s%s%s %s %s(linked to different target)%s\n" "$RED" "$ERR" "$RESET" "$name" "$DIM" "$RESET"
    fi
    continue
  elif [[ -e "$dst" ]]; then
    printf "%s%s%s %s %s(exists, not a symlink)%s\n" "$RED" "$ERR" "$RESET" "$name" "$DIM" "$RESET"
    continue
  fi

  if ln -s "$src" "$dst" 2>/dev/null; then
    # Verbose: detailed output
    if [ "$verbose" -eq 1 ]; then
      printf "%s%s%s %s\n" "$GREEN" "$OK" "$RESET" "$name"
    fi
    # Concise: visual link representation with fixed width
    if [ "$verbose" -eq 0 ]; then
      printf "%s%s%s %-*s ◀%s● %s %s\n" "$GREEN" "$LINK_ICON" "$RESET" $max_len "$name" "$connection_line" "$icon" "$name"
    fi
    created=$((created+1))
  else
    printf "%s%s%s %s %s(link failed)%s\n" "$RED" "$ERR" "$RESET" "$name" "$DIM" "$RESET"
  fi
done

# Restore original shell options
if [[ -n "$original_shopt" ]]; then
  eval "$original_shopt"
else
  shopt -u dotglob nullglob 2>/dev/null || true
fi

if [[ $had_any -eq 0 ]]; then
  printf "%sNothing to link: %s is empty.%s\n" "$DIM" "$TWIN" "$RESET"
fi

# Summary only in verbose mode
if [ "$verbose" -eq 1 ]; then
  printf "\nCreated %d link(s).\n" "$created"
fi

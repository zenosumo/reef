#!/usr/bin/env bash
# dk-kick — move a file into the twin folder (default "-dk") and leave a symlink.
# Usage:
#   dk-kick <file> [--suffix=-dk]
# Behavior:
#   - If twin folder missing, prompt to create it (Enter = Yes).
#   - Move the given file to the twin's root.
#   - Create a symlink at the original location pointing to the moved file.

set -u

# Config
SUFFIX="-dk"   # default twin suffix

# Colors/icons
GREEN="$(printf '\033[32m')"
YELLOW="$(printf '\033[33m')"
RED="$(printf '\033[31m')"
DIM="$(printf '\033[2m')"
RESET="$(printf '\033[0m')"
OK="✓"
WARN="⚠️"
FAIL="✗"

# Parse flags
for arg in "$@"; do
  case "$arg" in
    --suffix=*) SUFFIX="${arg#*=}";;
  esac
done

# Strip flags from $@ to get the first non-flag as the file arg
FILE_ARG=""
for arg in "$@"; do
  case "$arg" in
    --suffix=*) ;;  # skip
    --*) ;;         # ignore unknown flags for now
    *) FILE_ARG="$arg"; break;;
  esac
done

# Warn if no filename provided
if [[ -z "${FILE_ARG:-}" ]]; then
  printf "${YELLOW}${WARN}${RESET} A filename was expected. Usage: dk-kick <file> [--suffix=-dk]\n"
  exit 0
fi

# Practical realpath that works for our use case
_realpath() {
  local path="$1"
  
  # Use system realpath with fallback to manual resolution
  if command -v realpath >/dev/null 2>&1; then
    realpath -m "$path" 2>/dev/null || echo "$path"
  else
    # Make absolute if relative
    if [[ "$path" != /* ]]; then
      path="$PWD/$path"
    fi
    
    # Basic cleanup
    path="${path//\/\///}"  # compress multiple slashes
    path="${path%/}"        # remove trailing slash
    [[ -n "$path" ]] || path="/"
    
    echo "$path"
  fi
}

# Determine BASE and TWIN from current dir with improved logic
CWD="$(_realpath "$PWD")"
BASE=""
TWIN=""

# Check if current directory ends with suffix AND a non-suffix version exists
if [[ "$CWD" == *"$SUFFIX" ]]; then
  potential_base="${CWD%$SUFFIX}"
  # Only treat as twin if the base actually exists
  if [[ -d "$potential_base" ]]; then
    TWIN="$CWD"
    BASE="$(_realpath "$potential_base")"
  fi
fi

# If we haven't identified BASE/TWIN yet, assume we're in base
if [[ -z "$BASE" ]]; then
  BASE="$CWD"
  TWIN="$(_realpath "${CWD}${SUFFIX}")"
fi

# Sanity check: BASE and TWIN shouldn't be the same
if [[ "$BASE" == "$TWIN" ]]; then
  printf "${RED}${FAIL}${RESET} Base and twin directories are identical. Check your suffix configuration.\n" >&2
  exit 1
fi

# Base must exist
if [[ ! -d "$BASE" ]]; then
  printf "${RED}${FAIL}${RESET} Base folder not found: %s\n" "$BASE" >&2
  exit 1
fi

# Check write permissions on base directory
if [[ ! -w "$BASE" ]]; then
  printf "${RED}${FAIL}${RESET} No write permission on base directory: %s\n" "$BASE" >&2
  exit 1
fi

# Ensure twin exists (prompt if not)
if [[ ! -d "$TWIN" ]]; then
  printf "${YELLOW}${WARN}${RESET} Twin folder not found: %s\n" "$TWIN"
  printf "Create it? [Y/n] "
  read -r reply
  reply="${reply:-y}"
  case "$reply" in
    y|Y|"")
      if mkdir -p -- "$TWIN"; then
        printf "${GREEN}${OK}${RESET} Created twin: %s\n" "$TWIN"
      else
        printf "${RED}${FAIL}${RESET} Failed to create twin: %s\n" "$TWIN" >&2
        exit 1
      fi
      ;;
    n|N)
      printf "${YELLOW}${WARN}${RESET} Aborted: twin not created.\n"
      exit 0
      ;;
    *)
      # Default to yes for any other input (Enter = Yes per spec)
      if mkdir -p -- "$TWIN"; then
        printf "${GREEN}${OK}${RESET} Created twin: %s\n" "$TWIN"
      else
        printf "${RED}${FAIL}${RESET} Failed to create twin: %s\n" "$TWIN" >&2
        exit 1
      fi
      ;;
  esac
fi

# Check write permissions on twin directory
if [[ ! -w "$TWIN" ]]; then
  printf "${RED}${FAIL}${RESET} No write permission on twin directory: %s\n" "$TWIN" >&2
  exit 1
fi

# Resolve source path
if [[ "$FILE_ARG" = /* ]]; then
  SRC="$FILE_ARG"
else
  SRC="$PWD/$FILE_ARG"
fi
SRC="$(_realpath "$SRC")"

# Validations
if [[ ! -e "$SRC" ]]; then
  printf "${RED}${FAIL}${RESET} No such file: %s\n" "$SRC" >&2
  exit 1
fi

# Check if source is readable/moveable
if [[ ! -r "$SRC" ]]; then
  printf "${RED}${FAIL}${RESET} Cannot read source file: %s\n" "$SRC" >&2
  exit 1
fi

# Check if parent directory allows file removal
SRC_DIR="$(dirname -- "$SRC")"
if [[ ! -w "$SRC_DIR" ]]; then
  printf "${RED}${FAIL}${RESET} Cannot move file from: %s (no write permission)\n" "$SRC_DIR" >&2
  exit 1
fi

# Don't "kick" items already in the twin
case "$SRC" in
  "$TWIN"/*)
    printf "${YELLOW}${WARN}${RESET} File is already inside the twin: %s\n" "$SRC"
    exit 0
    ;;
esac

# If source is a symlink, warn but allow (might be legitimate use case)
if [[ -L "$SRC" ]]; then
  printf "${YELLOW}${WARN}${RESET} Source is a symlink: %s\n" "$SRC"
  printf "This will move the symlink itself, not its target. Continue? [y/N] "
  read -r reply
  case "$reply" in
    y|Y) ;;
    *) 
      printf "${YELLOW}${WARN}${RESET} Aborted.\n"
      exit 0
      ;;
  esac
fi

NAME="$(basename -- "$SRC")"
DST="$TWIN/$NAME"

# Avoid overwriting an existing target in twin
if [[ -e "$DST" || -L "$DST" ]]; then
  printf "${RED}${FAIL}${RESET} Target already exists in twin: %s\n" "$DST" >&2
  exit 1
fi

printf "Moving: ${DIM}%s${RESET}\n" "$SRC"
printf "To:     ${DIM}%s${RESET}\n" "$DST"
printf "Link:   ${DIM}%s${RESET}\n\n" "$SRC"

# Move the file/dir, then create a symlink at the original location
if mv -- "$SRC" "$DST"; then
  printf "${GREEN}${OK}${RESET} Moved → %s\n" "$DST"
else
  printf "${RED}${FAIL}${RESET} Move failed: %s → %s\n" "$SRC" "$DST" >&2
  exit 1
fi

# Create symlink back at original location
if ln -s -- "$DST" "$SRC"; then
  printf "${GREEN}${OK}${RESET} Linked → %s → %s\n" "$SRC" "$DST"
  printf "\n${GREEN}${OK}${RESET} Done.\n"
else
  printf "${RED}${FAIL}${RESET} Failed to create symlink at: %s\n" "$SRC" >&2
  
  # Attempt rollback: move file back to original location
  printf "${YELLOW}${WARN}${RESET} Attempting rollback...\n"
  if mv -- "$DST" "$SRC" 2>/dev/null; then
    printf "${GREEN}${OK}${RESET} Rollback successful: file restored to %s\n" "$SRC"
    exit 1
  else
    printf "${RED}${FAIL}${RESET} Rollback failed! File is now at: %s\n" "$DST" >&2
    printf "${RED}${FAIL}${RESET} You may need to manually move it back to: %s\n" "$SRC" >&2
    exit 1
  fi
fi
